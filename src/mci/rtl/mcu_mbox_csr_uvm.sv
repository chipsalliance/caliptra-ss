
// This file was autogenerated by PeakRDL-uvm
package mcu_mbox_csr_uvm;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    `include "mcu_mbox_csr_covergroups.svh"
    // Mem - mcu_mbox_csr::MBOX_SRAM
    class mcu_mbox_csr__MBOX_SRAM extends uvm_reg_block;
        rand uvm_mem m_mem;
        
        function new(string name = "mcu_mbox_csr__MBOX_SRAM");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4.0, UVM_LITTLE_ENDIAN);
            this.m_mem = new("m_mem", 524288, 32, "RW");
            this.m_mem.configure(this);
            this.default_map.add_mem(this.m_mem, 0);
        endfunction : build
    endclass : mcu_mbox_csr__MBOX_SRAM

    // Reg - mcu_mbox_csr::mbox_lock
    class mcu_mbox_csr__mbox_lock extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_lock_bit_cg lock_bit_cg[1];
        mcu_mbox_csr__mbox_lock_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "mcu_mbox_csr__mbox_lock");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "RS", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_lock

    // Reg - mcu_mbox_csr::mbox_user
    class mcu_mbox_csr__mbox_user extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_user_bit_cg user_bit_cg[32];
        mcu_mbox_csr__mbox_user_fld_cg fld_cg;
        rand uvm_reg_field user;

        function new(string name = "mcu_mbox_csr__mbox_user");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.user = new("user");
            this.user.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(user_bit_cg[bt]) user_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_user

    // Reg - mcu_mbox_csr::mbox_target_user
    class mcu_mbox_csr__mbox_target_user extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_target_user_bit_cg user_bit_cg[32];
        mcu_mbox_csr__mbox_target_user_fld_cg fld_cg;
        rand uvm_reg_field user;

        function new(string name = "mcu_mbox_csr__mbox_target_user");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.user = new("user");
            this.user.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(user_bit_cg[bt]) user_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_target_user

    // Reg - mcu_mbox_csr::mbox_target_user_valid
    class mcu_mbox_csr__mbox_target_user_valid extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_target_user_valid_bit_cg valid_bit_cg[1];
        mcu_mbox_csr__mbox_target_user_valid_fld_cg fld_cg;
        rand uvm_reg_field valid;

        function new(string name = "mcu_mbox_csr__mbox_target_user_valid");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.valid = new("valid");
            this.valid.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(valid_bit_cg[bt]) valid_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_target_user_valid

    // Reg - mcu_mbox_csr::mbox_cmd
    class mcu_mbox_csr__mbox_cmd extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_cmd_bit_cg command_bit_cg[32];
        mcu_mbox_csr__mbox_cmd_fld_cg fld_cg;
        rand uvm_reg_field command;

        function new(string name = "mcu_mbox_csr__mbox_cmd");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.command = new("command");
            this.command.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(command_bit_cg[bt]) command_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_cmd

    // Reg - mcu_mbox_csr::mbox_dlen
    class mcu_mbox_csr__mbox_dlen extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_dlen_bit_cg length_bit_cg[32];
        mcu_mbox_csr__mbox_dlen_fld_cg fld_cg;
        rand uvm_reg_field length;

        function new(string name = "mcu_mbox_csr__mbox_dlen");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.length = new("length");
            this.length.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(length_bit_cg[bt]) length_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_dlen

    // Reg - mcu_mbox_csr::mbox_execute
    class mcu_mbox_csr__mbox_execute extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_execute_bit_cg execute_bit_cg[1];
        mcu_mbox_csr__mbox_execute_fld_cg fld_cg;
        rand uvm_reg_field execute;

        function new(string name = "mcu_mbox_csr__mbox_execute");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.execute = new("execute");
            this.execute.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(execute_bit_cg[bt]) execute_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_execute

    // Reg - mcu_mbox_csr::mbox_target_status
    class mcu_mbox_csr__mbox_target_status extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_target_status_bit_cg status_bit_cg[4];
        mcu_mbox_csr__mbox_target_status_bit_cg done_bit_cg[1];
        mcu_mbox_csr__mbox_target_status_fld_cg fld_cg;
        rand uvm_reg_field status;
        rand uvm_reg_field done;

        function new(string name = "mcu_mbox_csr__mbox_target_status");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.status = new("status");
            this.status.configure(this, 4, 0, "RW", 1, 'h0, 1, 1, 0);
            this.done = new("done");
            this.done.configure(this, 1, 4, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(status_bit_cg[bt]) status_bit_cg[bt] = new();
                foreach(done_bit_cg[bt]) done_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_target_status

    // Reg - mcu_mbox_csr::mbox_cmd_status
    class mcu_mbox_csr__mbox_cmd_status extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_cmd_status_bit_cg status_bit_cg[4];
        mcu_mbox_csr__mbox_cmd_status_fld_cg fld_cg;
        rand uvm_reg_field status;

        function new(string name = "mcu_mbox_csr__mbox_cmd_status");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.status = new("status");
            this.status.configure(this, 4, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(status_bit_cg[bt]) status_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_cmd_status

    // Reg - mcu_mbox_csr::mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760
    class mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760 extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760_bit_cg ecc_single_error_bit_cg[1];
        mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760_bit_cg ecc_double_error_bit_cg[1];
        mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760_fld_cg fld_cg;
        rand uvm_reg_field ecc_single_error;
        rand uvm_reg_field ecc_double_error;

        function new(string name = "mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ecc_single_error = new("ecc_single_error");
            this.ecc_single_error.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            this.ecc_double_error = new("ecc_double_error");
            this.ecc_double_error.configure(this, 1, 1, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ecc_single_error_bit_cg[bt]) ecc_single_error_bit_cg[bt] = new();
                foreach(ecc_double_error_bit_cg[bt]) ecc_double_error_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760

    // Addrmap - mcu_mbox_csr
    class mcu_mbox_csr extends uvm_reg_block;
        rand mcu_mbox_csr__MBOX_SRAM MBOX_SRAM;
        rand mcu_mbox_csr__mbox_lock mbox_lock;
        rand mcu_mbox_csr__mbox_user mbox_user;
        rand mcu_mbox_csr__mbox_target_user mbox_target_user;
        rand mcu_mbox_csr__mbox_target_user_valid mbox_target_user_valid;
        rand mcu_mbox_csr__mbox_cmd mbox_cmd;
        rand mcu_mbox_csr__mbox_dlen mbox_dlen;
        rand mcu_mbox_csr__mbox_execute mbox_execute;
        rand mcu_mbox_csr__mbox_target_status mbox_target_status;
        rand mcu_mbox_csr__mbox_cmd_status mbox_cmd_status;
        rand mcu_mbox_csr__mbox_hw_status_ecc_double_error_38cec4b0_ecc_single_error_9c62b760 mbox_hw_status;

        function new(string name = "mcu_mbox_csr");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_LITTLE_ENDIAN);
            this.MBOX_SRAM = new("MBOX_SRAM");
            this.MBOX_SRAM.configure(this);
            this.MBOX_SRAM.build();
            this.default_map.add_submap(this.MBOX_SRAM.default_map, 'h0);
            this.mbox_lock = new("mbox_lock");
            this.mbox_lock.configure(this);

            this.mbox_lock.build();
            this.default_map.add_reg(this.mbox_lock, 'h200000);
            this.mbox_user = new("mbox_user");
            this.mbox_user.configure(this);

            this.mbox_user.build();
            this.default_map.add_reg(this.mbox_user, 'h200004);
            this.mbox_target_user = new("mbox_target_user");
            this.mbox_target_user.configure(this);

            this.mbox_target_user.build();
            this.default_map.add_reg(this.mbox_target_user, 'h200008);
            this.mbox_target_user_valid = new("mbox_target_user_valid");
            this.mbox_target_user_valid.configure(this);

            this.mbox_target_user_valid.build();
            this.default_map.add_reg(this.mbox_target_user_valid, 'h20000c);
            this.mbox_cmd = new("mbox_cmd");
            this.mbox_cmd.configure(this);

            this.mbox_cmd.build();
            this.default_map.add_reg(this.mbox_cmd, 'h200010);
            this.mbox_dlen = new("mbox_dlen");
            this.mbox_dlen.configure(this);

            this.mbox_dlen.build();
            this.default_map.add_reg(this.mbox_dlen, 'h200014);
            this.mbox_execute = new("mbox_execute");
            this.mbox_execute.configure(this);

            this.mbox_execute.build();
            this.default_map.add_reg(this.mbox_execute, 'h200018);
            this.mbox_target_status = new("mbox_target_status");
            this.mbox_target_status.configure(this);

            this.mbox_target_status.build();
            this.default_map.add_reg(this.mbox_target_status, 'h20001c);
            this.mbox_cmd_status = new("mbox_cmd_status");
            this.mbox_cmd_status.configure(this);

            this.mbox_cmd_status.build();
            this.default_map.add_reg(this.mbox_cmd_status, 'h200020);
            this.mbox_hw_status = new("mbox_hw_status");
            this.mbox_hw_status.configure(this);

            this.mbox_hw_status.build();
            this.default_map.add_reg(this.mbox_hw_status, 'h200024);
        endfunction : build
    endclass : mcu_mbox_csr

    `include "mcu_mbox_csr_sample.svh"
endpackage: mcu_mbox_csr_uvm
