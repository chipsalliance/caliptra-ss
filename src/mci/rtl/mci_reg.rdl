// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////
// MCI Registers
addrmap mci_reg {

    ////////////////////////////////////////////////////////////////
    // Properties
    desc="Address map for Manufacturer Control Interface Block architectural registers";

    addressing = regalign; // This is the default if not specified
    lsb0 = true; // lsb0 property is implicit/default. See docs for
                 // SystemRDL 2.0 sections 9.1 and 13.4
    littleendian = true;

    default hw = na;
    signal {activelow; async; cpuif_reset; field_reset;} mci_rst_b;
    signal {activelow; async;} mcu_rst_b; // uC reset only
    signal {activelow; async;} mci_pwrgood;

    //signal to indicate request origin
    // TODO need these?
    signal {} cptra_req;
    signal {} mcu_req;
    //signal to indicate request is coming from soc side
    signal {} soc_req; // FIXME is this needed?

    //defined fields by access type
    // TODO
    field rw_rw_sticky_hw { sw=rw; hw=rw; we=true; woclr = true; resetsignal = mci_pwrgood;}; //W1C            - used by HW ERROR regs
    field rw_rw_sticky    { sw=rw; hw=rw; we=true; swmod = true; resetsignal = mci_pwrgood;}; //writes enabled - used by FW ERROR regs

    ////////////////////////////////////////////////////////////////
    // Registers

    // ----------------------------------------
    // ------------ IDENTIFICATION ------------
    reg {
        name = "Manufacturer Control Interface Capabilities";
        desc = "Reports configuration and build options for MCI.
                [br]Caliptra Access: RO
                [br]MCU Access:      RO
                [br]SoC Access:      RO";
        field {desc = "Number of Mailboxes in MCI"; hw=w; sw=r;} NUM_MBOX[4];
    } CAPABILITIES;
    reg {
        name = "MCI/MCU HW RevID";
        desc = "HW revision ID for Manufacturer Control components (MCU & MCI) that matches the official
                final release milestone of Caliptra Subsystem.
                [br]Caliptra Access: RO
                [br]MCU Access:      RO
                [br]SOC Access:      RO";
        field {desc = "Official release version. Bit field encoding is:
                       [br][lb]15:12[rb] Major version
                       [br][lb]11: 8[rb] Minor version
                       [br][lb] 7: 0[rb] Patch version";
               sw=r;} MC_GENERATION[16]=0x1000;
        field {sw=r; hw=w; resetsignal = mci_rst_b;} SOC_STEPPING_ID[16]=0; // TODO
    } HW_REV_ID;
    reg {
        name = "MCU FW RevID";
        desc = "MCU FW revision ID
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {sw=rw; swwe = mcu_req; resetsignal = mci_rst_b;} REV_ID[32]=0;
    } FW_REV_ID[2];
    reg {
        name = "MCU HW Config";
        desc = "MCU HW Configuration
                [br]Caliptra Access: RO
                [br]MCU Access:      RO
                [br]SOC Access:      RO";
        // No storage, i.e. no resetsignal
        field {sw=r; hw=w;} RSVD_en;
    } HW_CONFIG;

    // ----------------------------------------
    // ---------------- STATUS ----------------
    reg {
        name = "Boot Status";
        desc = "Reports the boot status.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO
                [br]TAP Access [in debug/manuf mode]: RO";
        field {swwe = mcu_req; hw=r; resetsignal = mci_rst_b;} status[32]=0;
    } BOOT_STATUS @0x20;
    reg {
        name = "Flow Status";
        desc = "Reports the status of the firmware flows.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc="Generic Status";                                            sw=rw; swwe = mcu_req; hw=r ; resetsignal = mci_rst_b;} status[24]=0;
        field {desc="DEV ID CSR ready";                                          sw=r;                         /* no storage, no reset */} rsvd[3]=0;
        field {desc="Boot FSM State";                                            sw=r;                  hw=w ; /* no storage, no reset */} boot_fsm_ps[5];
    } FLOW_STATUS;
    reg {
        name = "Reset Reason";
        desc = "Indicates to ROM the originating cause for the PC to be reset to 0.
                Firmware Update Reset indicator is reset by the warm reset.
                Warm Reset indicator is reset by the cold reset.
                [br]Caliptra Access: RO
                [br]MCU Access:      RO
                [br]SOC Access:      RO";
        field {desc = "FW update reset has been executed"; sw=r; hw=rw; we=true; resetsignal = mci_rst_b;  } FW_UPD_RESET=0;
        field {desc = "Warm reset has been executed";      sw=r; hw=rw;          resetsignal = mci_pwrgood;} WARM_RESET=0;
    } RESET_REASON;

    // ----------------------------------------
    // ---------------- ERROR -----------------
    reg {
        name = "Hardware Error Fatal";
        desc = "Indicates fatal hardware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, clearing
                the bit in this register will not cause the interrupt to deassert.
                Only an MCI reset will clear the fatal error interrupt.
                [br]Caliptra Access: RW1C
                [br]MCU Access:      RW1C
                [br]SOC Access:      RW1C";
        rw_rw_sticky_hw RSVD=1'b0;
    } HW_ERROR_FATAL @0x40;
    reg {
        name = "Hardware Error Non-Fatal";
        desc = "Indicates non-fatal hardware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_non_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, any
                change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask 
                [/list]
                [br]Caliptra Access: RW1C
                [br]MCU Access:      RW1C
                [br]SOC Access:      RW1C";
        rw_rw_sticky_hw RSVD=1'b0;
    } HW_ERROR_NON_FATAL;
    reg {
        name = "Firmware Error Fatal";
        desc = "Indicates fatal firmware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, clearing
                the bit in this register will not cause the interrupt to deassert.
                Only an MCI reset will clear the fatal error interrupt.
                [br]Caliptra Access: RW
                [br]MCU Access:      RW
                [br]SOC Access:      RW";
        rw_rw_sticky error_code[32]=0; 
    } FW_ERROR_FATAL;
    reg {
        name = "Firmware Error Non-Fatal";
        desc = "Indicates non-fatal firmware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_non_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, any
                change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask
                [/list]
                [br]Caliptra Access: RW
                [br]MCU Access:      RW
                [br]SOC Access:      RW";
        rw_rw_sticky error_code[32]=0; 
    } FW_ERROR_NON_FATAL;
    reg {
        name = "Hardware Error Encoding";
        desc = "Encoded error value for hardware errors.
                [br]Caliptra Access: RW
                [br]SOC Access:      RW";
         field {resetsignal = mci_pwrgood; hw=r;}error_code[32]=0; 
    } HW_ERROR_ENC;
    reg {
        name = "Firmware Error Encoding";
        desc = "Encoded error value for firmware errors.
                [br]Caliptra Access: RW
                [br]SOC Access:      RW";
        field {resetsignal = mci_pwrgood; hw=r;} error_code[32]=0; 
    } FW_ERROR_ENC;
    reg {
        name = "Firmware Extended Error Information";
        desc = "Firmware Extended Error information for firmware errors.
                [br]Caliptra Access: RW
                [br]SOC Access:      RW";
        field {resetsignal = mci_pwrgood; hw=r;} error_info[32]=0; 
    } FW_EXTENDED_ERROR_INFO[8];

    // TODO add FW/HW ERROR masks (like in Caliptra)?

    // ----------------------------------------
    // ----------------- WDT ------------------
    //Timer1
    reg {
        name = "WDT Timer1 EN register";
        desc = "Watchdog timer1 enable register
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SoC Access:      RO";
        field {desc = "WDT timer1 enable"; hw = r; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b;} timer1_en = 1'b0;
    } WDT_TIMER1_EN @0x80;

    reg {
        name = "WDT Timer1 CTRL register";
        desc = "Watchdog timer1 control register
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "WDT timer1 restart"; hw = r; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b; singlepulse;} timer1_restart = 1'b0;
    } WDT_TIMER1_CTRL;

    reg {
        name = "WDT Timer1 Timeout Period register";
        desc = "Watchdog timer1 timeout register
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "WDT timer1 timeout period"; hw = r; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b;} timer1_timeout_period[32] = 32'hFFFFFFFF;
    } WDT_TIMER1_TIMEOUT_PERIOD[2]; // This reflects WDT_TIMEOUT_PERIOD_NUM_DWORDS in FIXME _pkg

    //Timer2
    reg {
        name = "WDT Timer2 EN register";
        desc = "Watchdog timer2 enable register. Note: Setting this to 1 will disable the default cascaded mode and will have both timers count independently.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO ";
        field {desc = "WDT timer2 enable"; hw = r; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b;} timer2_en = 1'b0;
    } WDT_TIMER2_EN;

    reg {
        name = "WDT Timer2 CTRL register";
        desc = "Watchdog timer2 control register
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "WDT timer2 restart"; hw = r; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b; singlepulse;} timer2_restart = 1'b0;
    } WDT_TIMER2_CTRL;

    reg {
        name = "WDT Timer2 Timeout Period register";
        desc = "Watchdog timer2 timeout register
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "WDT timer2 timeout period"; hw = r; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b;} timer2_timeout_period[32] = 32'hFFFFFFFF;
    } WDT_TIMER2_TIMEOUT_PERIOD[2]; //This reflects WDT_TIMEOUT_PERIOD_NUM_DWORDS in FIXME _pkg

    //Status
    reg {
        name = "WDT STATUS register";
        desc = "Watchdog timer status register
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "Timer1 timed out, timer2 enabled"; hw = rw; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b;} t1_timeout = 1'b0;
        field {desc = "Timer2 timed out"; hw = rw; sw = rw; swwe = mcu_req; resetsignal = mci_rst_b;} t2_timeout = 1'b0;
    } WDT_STATUS;

    // Req
    reg {
        name = "WDT1 Config";
        desc = "SOC provided count in cycles for WDT1 timeout.
                [br]Caliptra Access: RW
                [br]MCU Access:      RW
                [br]SOC Access:      RW";
        field {sw=rw; hw=na; resetsignal = mci_pwrgood;} TIMEOUT[32]=0;
    } WDT_CFG[2] @0xB0;

    // ----------------------------------------
    // ---------------- TIMER -----------------
    reg {
        name = "Timer Config";
        desc = "Provides the clock period of the system clock.
                Used to standardize the RISC-V Standard MTIME count register.
                Clock Period is indicated as an integer number of picoseconds.";
        field {desc = "Period in (ps)"; sw=rw; hw=na; resetsignal = mci_pwrgood;} clk_period[32] = 32'h0;
    } MCU_TIMER_CONFIG @0xC0;
    reg {
        name = "MCU Clock Gating En";
        field {sw=rw; hw=na; resetsignal = mci_rst_b;} FIXME=0;
         // TODO
    } MCU_CLK_GATING_EN;

    reg {
        name = "mtime low";
        desc = "RISC-V Standard Machine-mode Time Counter, lower 32-bits.
                [br]Frequency of counter is indicated in MCU_TIMER_CONFIG.clk_period.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "Counter Low" ; sw = rw; precedence = sw; swmod = true; hw = r; swwe = mcu_req; counter = true; incrvalue = 1; overflow = true; resetsignal = mci_pwrgood;} count_l[32] = 32'h0;
    } MCU_RV_MTIME_L;

    reg {
        name = "mtime high";
        desc = "RISC-V Standard Machine-mode Time Counter, upper 32-bits.
                [br]Frequency of counter is indicated in MCU_TIMER_CONFIG.clk_period.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "Counter High"; sw = rw; precedence = sw; swmod = true; hw = r; swwe = mcu_req; counter = true; incrvalue = 1;                  resetsignal = mci_pwrgood;} count_h[32] = 32'h0;
    } MCU_RV_MTIME_H;

    reg {
        name = "mtimecmp low";
        desc = "RISC-V Standard Machine-mode Time Counter Compare Value, lower 32-bits.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "Count Compare Low" ; sw = rw; hw = r; swwe = mcu_req; resetsignal = mci_pwrgood;} compare_l[32] = 32'h0;
    } MCU_RV_MTIMECMP_L;

    reg {
        name = "mtimecmp high";
        desc = "RISC-V Standard Machine-mode Time Counter Compare Value, upper 32-bits.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc = "Count Compare High"; sw = rw; hw = r; swwe = mcu_req; resetsignal = mci_pwrgood;} compare_h[32] = 32'h0;
    } MCU_RV_MTIMECMP_H;


    // ----------------------------------------
    // ----------- RESET/BOOT MGMT ------------
    reg {
        name = "Reset Request";
        desc = "Used by Caliptra to request an MCU reset to facilitate firmware updates.
                Reset request is the first step in a handshake protocol between Caliptra and
                the MCU before the MCU is reset and executes updated firmware.
                [br]Caliptra Access: RW
                [br]MCU Access:      RO
                [br]SOC Access:      RO";
        field { desc = "Request. Writable by Caliptra. Causes MCU interrupt to assert."; sw=rw; hw=r; hwclr=true; swwe=cptra_req; resetsignal=mci_rst_b; } req=1'b0;
        field { desc = "Clear. Writable by Caliptra. On set, this bit autoclears, RESET_REQUEST.req clears, and MCU reset deasserts."; sw=rw; hw=r; swwe=cptra_req; onwrite=woset; singlepulse=true; resetsignal=mci_rst_b; } clr=1'b0;
    } RESET_REQUEST @0x100;
    reg {
        name = "Reset Ack";
        desc = "Used by MCU to acknowledge reset request by Caliptra for a firmware update.
                If RESET_REQUEST.req is set, a write by MCU to set the ack bit causes the MCU reset to assert.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field { desc = "Ack. Writable by MCU. Causes MCU reset to assert (if RESET_REQUEST.req is also set)"; sw=rw; hw=r; hwclr=true; swwe=mcu_req; resetsignal=mci_rst_b; } ack=1'b0;
    } RESET_ACK;
// TODO finish desc for these
    reg {
        field { desc="fixme";} go=1'b0;
    } CALIPTRA_BOOT_GO;
    reg {
        field {sw=r; hw=w; } id;
    } CALIPTRA_AXI_ID;
    reg {
        name = "Firmware SRAM Exec Region Size";
        desc = "Dynamic size assignment for the region of sram that contains executable instructions for MCU.";
        field { desc="Size (in multiples of 4KiB)"; sw=rw; hw=r; swwe=true; } size[16] = 16'h0;
    } FW_SRAM_EXEC_REGION_SIZE;
    reg {
        name = "Runtime Lock";
        desc = "Writable only by Caliptra, only when already at 0. (W1S, cleared only by MCU FW Update reset).
                [br]With a value of 0, only the Caliptra AXI ID is allowed to access the Updateable Execution SRAM region in the MCU.
                [br]Writing 1 to this register enables the MCU LSU and IFU AXI IDs to access the Updateable Execution SRAM Region.
                AXI IDs are provided as integration parameter/macro to MCU. 
                Observing a value of 1 in this register (after exiting a reset) also indicates to MCU ROM that it may perform context switch to RT image.";
        field {/*TODO*/ sw=rw;} lock=0;
    } RUNTIME_LOCK;

    // TODO nmi_vector, reset_vector

    // ----------------------------------------
    // ------------ AxUSER CONFIG -------------
    reg { field {sw=rw;/*TODO*/ } id[32]=0;} MBOX0_VALID_AXI_ID [5] @0x180;
    reg { field {sw=rw;/*TODO*/ } lock=0;  } MBOX0_VALID_AXI_ID_LOCK [5] @0x1A0;
    reg { field {sw=rw;/*TODO*/ } id[32]=0;} MBOX1_VALID_AXI_ID [5] @0x1C0;
    reg { field {sw=rw;/*TODO*/ } lock=0;  } MBOX1_VALID_AXI_ID_LOCK [5] @0x1E0;

    // ----------------------------------------
    // ------------ DEBUG/GENERIC -------------
    reg { field {/*TODO*/sw=r;  hw=w;} wires[32]=32'b0; } GENERIC_INPUT_WIRES[2] @0x400;
    reg { field {/*TODO*/sw=rw; hw=r;} wires[32]=32'b0; } GENERIC_OUTPUT_WIRES[2];
    reg { 
        field {sw=rw; hw=na; resetsignal = mci_rst_b;} FIXME=0;
    } DEBUG_IN; // i.e. stdin
    reg { 
        field {sw=rw; hw=na; resetsignal = mci_rst_b;} FIXME=0;
    } DEBUG_OUT; // i.e. stdout

    reg {
        name = "FUSE Write Done";
        desc = "Set to indicate that all fuse registers have been populated in MCI.
                Locks fuse registers from further modification.
                Sticky until cold reset once set.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {sw = rw; hw=r; swwel; swmod=true; resetsignal = mci_pwrgood;} done=1'h0; // TODO
    } FUSE_WR_DONE @0x440;

    reg {
        name = "Production Debug Unlock PK HASH";
        desc = "Production Debug Unlock PK HASH. Initialized from strap inputs, overwritable by MCU until FUSE_WR_DONE is set.
                Once FUSE_WR_DONE is set value persists until cold reset.
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {sw = rw; hw = rw; we; swwel; resetsignal = mci_pwrgood;} hash[32]=32'h0; // TODO
    } PROD_DEBUG_UNLOCK_PK_HASH_REG[8][12] @0x480;

    // ----------------------------------------
    // ----- DATA_VAULT/SCRATCH/RESERVED ------
     reg {
         name = "STICKY DATA VAULT CTRL";
         desc = "Controls for the Sticky Data Vault Entries (cleared on cold reset)
                 [br]Caliptra Access: RO
                 [br]MCU Access:      RW
                 [br]SOC Access:      RO";
         field {desc="Lock writes to this entry. Writes will be suppressed when locked.";
                sw=rw; swwel=true; hw=r; resetsignal=mci_pwrgood;} lock_entry=0; //TODO Shoud reflect STICKY_DV_NUM_ENTRIES from dv_defines_pkg.sv
     } STICKY_DATA_VAULT_CTRL[10] @0x800;

     reg {
         name = "STICKY DATA VAULT ENTRY";
         desc = "Sticky Data Vault Entry (cleared on cold reset). Lockable.
                 [br]Caliptra Access: RO
                 [br]MCU Access:      RW
                 [br]SOC Access:      RO";
         field {desc="DataVault Entry (cleared on cold reset)"; sw=rw; hw=na; swwel=true; resetsignal = mci_pwrgood;} lock_entry=0;
     } STICKY_DATA_VAULT_ENTRY[10][12];//TODO Shoud reflect STICKY_DV_NUM_ENTRIES and DV_NUM_DWORDS from dv_defines_pkg.sv

     reg {
         name = "DATA VAULT CTRL";
         desc = "Controls for the Data Vault Entries (cleared on warm reset)
                 [br]Caliptra Access: RO
                 [br]MCU Access:      RW
                 [br]SOC Access:      RO";
         field {desc="Lock writes to this entry. Writes will be suppressed when locked.";
                sw=rw; swwel=true; hw=r; resetsignal=mcu_rst_b;} lock_entry=0; // TODO Shoud reflect DV_NUM_ENTRIES and DV_NUM_DWORDS from dv_defines_pkg.sv
     } DATA_VAULT_CTRL[10];// CAREFUL with the address extensions

     reg {
         name = "DATA VAULT ENTRY";
         desc = "Data Vault Entry (cleared on cold reset). Lockable.
                 [br]Caliptra Access: RO
                 [br]MCU Access:      RW
                 [br]SOC Access:      RO";
         field {desc="DataVault Entry (cleared on cold reset)"; sw=rw; hw=na; swwel=true; resetsignal = mci_pwrgood;} lock_entry=0;
     } DATA_VAULT_ENTRY[10][12];// TODO Shoud reflect DV_NUM_ENTRIES and DV_NUM_DWORDS from dv_defines_pkg.sv

     reg {
         name = "STICKY LOCKABLE SCRATCH REG CTRL";
         desc = "Sticky Scratch Register Controls (cleared on cold reset)
                 [br]Caliptra Access: RO
                 [br]MCU Access:      RW
                 [br]SOC Access:      RO";
         field {desc="Lock writes to the Scratch registers. Writes will be suppressed when locked.";
                sw=rw; swwel=true; hw=r; resetsignal=mci_pwrgood;} lock_entry=0;
     } STICKY_LOCKABLE_SCRATCH_REG_CTRL[8]; // TODO should reflect STICKY_LOCKQ_SCRATCH_NUM_ENTRIES

    reg {
        name = "STICKY LOCKABLE SCRATCH REG";
        desc = "Sticky Scratch Register Entries (cleared on cold reset)
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {sw=rw; swwel=true; hw=na; resetsignal=mci_pwrgood;} data[32]=0;
    } STICKY_LOCKABLE_SCRATCH_REG[8]; // TODO should reflect STICKY_LOCKQ_SCRATCH_NUM_ENTRIES

    reg {
        name = "LOCKABLE SCRATCH REG CTRL";
        desc = "Scratch Register Controls (cleared on warm reset)
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {desc="Lock writes to the Scratch registers. Writes will be suppressed when locked.";
               sw=rw; swwel=true; hw=r; resetsignal=mcu_rst_b;} lock_entry=0;
    } LOCKABLE_SCRATCH_REG_CTRL[10]; // TODO Shoud reflect LOCK_SCRATCH_NUM_ENTRIES from dv_defines_pkg.sv & CAREFUL with the address extensions

    reg {
        name = "LOCKABLE SCRATCH REG";
        desc = "Scratch Register Entry (cleared on cold reset)
                [br]Caliptra Access: RO
                [br]MCU Access:      RW
                [br]SOC Access:      RO";
        field {sw=rw; swwel=true; hw=na; resetsignal=mci_pwrgood;} data[32]=0;
    } LOCKABLE_SCRATCH_REG[10]; // TODO Shoud reflect LOCK_SCRATCH_NUM_ENTRIES from dv_defines_pkg.sv

     reg {
         name = "NON STICKY GENERIC SCRATCH REG";
         desc = "
                 [br]Caliptra Access: RO
                 [br]MCU Access:      RW
                 [br]SOC Access:      RO";
         field {sw=rw; hw=na; resetsignal=mci_rst_b;} data[32]=0; // FIXME mcu_rst_b instead?
     } NON_STICKY_GENERIC_SCRATCH_REG[8]; // TODO Shoud reflect NONSTICKY_SCRATCH_NUM_ENTRIES from dv_defines_pkg.sv & CAREFUL with the address extensions

////////////////////////////////////////////////////////////////
// Interrupts
/* -----------------------
 * Register File definitive definition
 * ----------------------- */

// Notifications are non-error events that occur during normal operation of the module.
// E.g. a completion of a job may produce a notification.
// Error and notification events are separated into separate status/trigger registers
// to allow effective priority allocation by software
regfile intr_block_t {


    /* -----------------------
     * Default properties for Register File
     * ----------------------- */

    name = "Interrupt Register Block";
    desc = "Set of registers to implement interrupt functionality
            for soc interface.
            All registers have the following access privileges:
            [br]Caliptra Access: RW
            [br]SOC Access:      RO";

    default regwidth = 32; // reg property
    default accesswidth = 32; // reg property
    default hw = na; // field property
    default swwel = soc_req; // Used in MBOX interrupt registers to avoid SoC write priv.


    /* -----------------------
     * Register definitive definitions
     * ----------------------- */

    /* ---- Global Interrupt Enable ---- */
    reg global_intr_en_t {
        name = "Per-Type Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event type that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Global enablement (for interrupts of the event types defined for this module)
        field {desc = "Global enable bit for all events of type 'Error'";       } error_en = 1'b0;
        field {desc = "Global enable bit for all events of type 'Notification'";} notif_en = 1'b0;
    };

    /* ---- Error Interrupt Enable ---- */
    reg error_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Specific enables for the events defined in this
        // event type in the instantiating peripheral.
        // FIXME add back ? field {desc = "Enable bit for Internal Errors";                                                            } error_internal_en = 1'b0;
        // FIXME add back ? field {desc = "Enable bit for Invalid Device in Pauser field";                                             } error_inv_dev_en  = 1'b0;
        // FIXME add back ? field {desc = "Enable bit for Failed Commands (invalid protocol or FW Fail Status)";                       } error_cmd_fail_en = 1'b0;
        // FIXME add back ? field {desc = "Enable bit for Bad Fuse received from SoC";                                                 } error_bad_fuse_en = 1'b0;
        // FIXME add back ? field {desc = "Enable bit for ICCM access blocked by lock";                                                } error_iccm_blocked_en = 1'b0;
        // FIXME add back ? field {desc = "Enable bit for Mailbox ECC Double-bit Error (uncorrectable)";                               } error_mbox_ecc_unc_en = 1'b0;
        field {desc = "Enable bit for WDT Timer1 timeout";                                                         } error_wdt_timer1_timeout_en = 1'b0;
        field {desc = "Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer";} error_wdt_timer2_timeout_en = 1'b0;
    };

    /* ---- Notification Interrupt Enable ---- */
    reg notif_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Specific enables for the events defined in this
        // event type in the instantiating peripheral.
        field {desc = "Enable bit for MCUS SRAM ECC Single-bit Error (corretable)";      } notif_mcu_sram_ecc_cor_en = 1'b0;
        // FIXME add back? field {desc = "Enable bit for Command Available";                         } notif_cmd_avail_en = 1'b0;
        // FIXME add back? field {desc = "Enable bit for Mailbox ECC Single-bit Error (correctable)";} notif_mbox_ecc_cor_en = 1'b0;
        // FIXME add back? field {desc = "Enable bit for Security State, Debug Locked transition";   } notif_debug_locked_en = 1'b0;
        // FIXME add back? field {desc = "Enable bit for Scan mode";                                 } notif_scan_mode_en = 1'b0;
        // FIXME add back? field {desc = "Enable bit for SoC requested the mailbox while locked";    } notif_soc_req_lock_en = 1'b0;
        // FIXME add back? field {desc = "Enable bit for Generic Input Wires Toggle";                } notif_gen_in_toggle_en = 1'b0;
    };

    /* ---- Error Interrupt Status ---- */
    reg error_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        // FIXME add back ? field {desc = "Internal Errors status bit";                                      } error_internal_sts = 1'b0;
        // FIXME add back ? field {desc = "Invalid Device in Pauser field status bit";                       } error_inv_dev_sts = 1'b0;
        // FIXME add back ? field {desc = "Failed Commands status bit (invalid protocol or FW Fail Status)"; } error_cmd_fail_sts = 1'b0;
        // FIXME add back ? field {desc = "Bad Fuse received from SoC status bit";                           } error_bad_fuse_sts = 1'b0;
        // FIXME add back ? field {desc = "ICCM access blocked by lock status bit";                          } error_iccm_blocked_sts = 1'b0;
        // FIXME add back ? field {desc = "Mailbox ECC Double-bit Error (uncorrectable) status bit";         } error_mbox_ecc_unc_sts = 1'b0;
        field {desc = "WDT Timer1 timeout status bit";                                   } error_wdt_timer1_timeout_sts = 1'b0;
        field {desc = "WDT Timer2 timeout status bit";                                   } error_wdt_timer2_timeout_sts = 1'b0;
    };

    /* ---- Notification Interrupt Status ---- */
    reg notif_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "MCU SRAM ECC Single-bit Error (correctable) status bit";} notif_mcu_sram_ecc_cor_sts = 1'b0;
        // FIXME add back? field {desc = "Command Available status bit";                         } notif_cmd_avail_sts = 1'b0;
        // FIXME add back? field {desc = "Mailbox ECC Single-bit Error (correctable) status bit";} notif_mbox_ecc_cor_sts = 1'b0;
        // FIXME add back? field {desc = "Security State, Debug Locked transition status bit";   } notif_debug_locked_sts = 1'b0;
        // FIXME add back? field {desc = "Scan mode status bit";                                 } notif_scan_mode_sts = 1'b0;
        // FIXME add back? field {desc = "SoC requested the mailbox while locked status bit";    } notif_soc_req_lock_sts = 1'b0;
        // FIXME add back? field {desc = "Generic Input Wires Toggle status bit";                } notif_gen_in_toggle_sts = 1'b0;
    };

    /* ---- Aggregated Interrupt Status ---- */
    reg global_intr_t {
        name = "Interrupt Status Aggregation Register type definition";
        desc = "Single bit indicating occurrence of any interrupt event
                of a given type. E.g. Notifications and Errors may drive
                to two separate interrupt registers. There may be
                multiple sources of Notifications or Errors that are
                aggregated into a single interrupt pin for that
                respective type. That pin feeds through this register
                in order to apply a global enablement of that interrupt
                event type.
                Nonsticky assertion.";

        default hw = w;
        default sw = r;
        default nonsticky intr;

        field {desc = "Interrupt Event Aggregation status bit"; swwel = false;} agg_sts = 1'b0;
    };

    /* ---- Error Interrupt Trigger ---- */
    reg error_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the trigger bit
                will pulse for 1 cycle then clear to 0. The pulse on the
                trigger register bit results in the corresponding interrupt
                status bit being set to 1.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;

        // Instantiate triggers bit-by-bit.
        // FIXME add back? field {desc = "Internal Errors trigger bit";                             } error_internal_trig = 1'b0;
        // FIXME add back? field {desc = "Invalid Device in Pauser field trigger bit";              } error_inv_dev_trig  = 1'b0;
        // FIXME add back? field {desc = "Failed Commands trigger bit";                             } error_cmd_fail_trig = 1'b0;
        // FIXME add back? field {desc = "Bad Fuse received from SoC trigger bit";                  } error_bad_fuse_trig = 1'b0;
        // FIXME add back? field {desc = "ICCM access blocked by lock trigger bit";                 } error_iccm_blocked_trig = 1'b0;
        // FIXME add back? field {desc = "Mailbox ECC Double-bit Error (uncorrectable) trigger bit";} error_mbox_ecc_unc_trig = 1'b0;
        field {desc = "WDT Timer1 timeout trigger bit";                          } error_wdt_timer1_timeout_trig = 1'b0;
        field {desc = "WDT Timer2 timeout trigger bit";                          } error_wdt_timer2_timeout_trig = 1'b0;
    };

    /* ---- Notification Interrupt Trigger ---- */
    reg notif_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the trigger bit
                will pulse for 1 cycle then clear to 0. The pulse on the
                trigger register bit results in the corresponding interrupt
                status bit being set to 1.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;

        // Instantiate triggers bit-by-bit.
        field {desc = "MCU SRAM ECC Single-bit Error (correctable) trigger bit";} notif_mcu_sram_ecc_cor_trig = 1'b0;
        // FIXME add back ? field {desc = "Command Available trigger bit";                         } notif_cmd_avail_trig = 1'b0;
        // FIXME add back ? field {desc = "Mailbox ECC Single-bit Error (correctable) trigger bit";} notif_mbox_ecc_cor_trig = 1'b0;
        // FIXME add back ? field {desc = "Security State, Debug Locked transition trigger bit";   } notif_debug_locked_trig = 1'b0;
        // FIXME add back ? field {desc = "Scan mode trigger bit";                                 } notif_scan_mode_trig = 1'b0;
        // FIXME add back ? field {desc = "SoC requested the mailbox while locked trigger bit";    } notif_soc_req_lock_trig = 1'b0;
        // FIXME add back ? field {desc = "Generic Input Wires Toggle trigger bit";                } notif_gen_in_toggle_trig = 1'b0;
    };

    /* ---- Interrupt Statistics Counter Incrementor ---- */
    reg intr_count_incr_t {
        name = "Interrupt Event Count Incrementor";
        desc = "Trigger the event counter to increment based on observing
                the rising edge of an interrupt event input from the
                Hardware. The same input signal that causes an interrupt
                event to be set (sticky) also causes this signal to pulse
                for 1 clock cycle, resulting in the event counter
                incrementing by 1 for every interrupt event.
                This is implemented as a down-counter (1-bit) that will
                decrement immediately on being set - resulting in a pulse";

        default hw = w;
        default sw = r; // Has to have some access.... ideally SW wouldn't even see this
        default hwset = true;
        default decrvalue = 1;
        default counter;

        field {desc = "Pulse mirrors interrupt event occurrence"; swwel = false;} pulse = 1'b0;
    };

    /* ---- Interrupt Statistics Counter ---- */
    reg intr_count_t {
        name = "Interrupt Event Counter";
        desc = "Provides statistics about the number of events that have
                occurred.
                Will not overflow ('incrsaturate').";

        default sw = rw;
        default hw = na;
        default incrvalue = 1;
        default incrsaturate = true;
        default counter;

        field {desc = "Count field";} cnt[32] = 32'h0;
    };


    /* ------------------------------------------------- Registers ------------------------------------------------- */
    // First 9 registers are static and always defined                                                               //
    global_intr_en_t  global_intr_en_r;      /* 1-bit per event type */                                              //
    error_intr_en_t   error_intr_en_r;       /* 1-bit per error */                                                   //
    notif_intr_en_t   notif_intr_en_r;       /* 1-bit per notification */                                            //
    global_intr_t     error_global_intr_r;   /* 1-bit aggregating all error interrupts with global enable */         //
    global_intr_t     notif_global_intr_r;   /* 1-bit aggregating all notification interrupts with global enable */  //
    error_intr_t      error_internal_intr_r; /* Error pending, SW write 1 to clear */                                //
    notif_intr_t      notif_internal_intr_r; /* Notification pending, SW write 1 to clear */                         //
    error_intr_trig_t error_intr_trig_r;     /* SW sets error bit for interrupt testing */                           //
    notif_intr_trig_t notif_intr_trig_r;     /* SW sets notification bit for interrupt testing */                    //
                                                                                                                     //
    // Align this set of registers; number of counters is based on peripheral event requirements                     //
    // FIXME add back? intr_count_t      error_internal_intr_count_r @0x100;  /* Per error */                                           //
    // FIXME add back? intr_count_t      error_inv_dev_intr_count_r;          /* Per error */                                           //
    // FIXME add back? intr_count_t      error_cmd_fail_intr_count_r;         /* Per error */                                           //
    // FIXME add back? intr_count_t      error_bad_fuse_intr_count_r;         /* Per error */                                           //
    // FIXME add back? intr_count_t      error_iccm_blocked_intr_count_r;     /* Per error */                                           //
    // FIXME add back? intr_count_t      error_mbox_ecc_unc_intr_count_r;     /* Per error */                                           //
    intr_count_t      error_wdt_timer1_timeout_intr_count_r @0x100; // FIXME remove 0x100 if not first count register/* Per error */                                         //
    intr_count_t      error_wdt_timer2_timeout_intr_count_r; /* Per error */                                         //
    intr_count_t      notif_mcu_sram_ecc_cor_intr_count_r @0x180;     /* Per notification */                                    //
    // FIXME add back? intr_count_t      notif_cmd_avail_intr_count_r @0x180; /* Per notification */                                    //
    // FIXME add back? intr_count_t      notif_mbox_ecc_cor_intr_count_r;     /* Per notification */                                    //
    // FIXME add back? intr_count_t      notif_debug_locked_intr_count_r;     /* Per notification */                                    //
    // FIXME add back? intr_count_t      notif_scan_mode_intr_count_r;        /* Per notification */                                    //
    // FIXME add back? intr_count_t      notif_soc_req_lock_intr_count_r;     /* Per notification */                                    //
    // FIXME add back? intr_count_t      notif_gen_in_toggle_intr_count_r;    /* Per notification */                                    //
                                                                                                                     //
    // These registers should be treated by SW as reserved, and ignored.                                             //
    // Offset at 0x200 gives enough space for 32 Errors and 32 Notifications                                         //
    // to be implemented (requiring 2*32 32-bit registers starting at                                                //
    // offset 0x100), and still allowing the entire regfile to fit                                                   //
    // inside a 1024-byte space.                                                                                     //
    // FIXME add back ? intr_count_incr_t error_internal_intr_count_incr_r @0x200; /* Per error count incrementor pulse */               //
    // FIXME add back ? intr_count_incr_t error_inv_dev_intr_count_incr_r;         /* Per error count incrementor pulse */               //
    // FIXME add back ? intr_count_incr_t error_cmd_fail_intr_count_incr_r;        /* Per error count incrementor pulse */               //
    // FIXME add back ? intr_count_incr_t error_bad_fuse_intr_count_incr_r;        /* Per error count incrementor pulse */               //
    // FIXME add back ? intr_count_incr_t error_iccm_blocked_intr_count_incr_r;    /* Per error count incrementor pulse */               //
    // FIXME add back ? intr_count_incr_t error_mbox_ecc_unc_intr_count_incr_r;    /* Per error count incrementor pulse */               //
    intr_count_incr_t error_wdt_timer1_timeout_intr_count_incr_r @0x200; // FIXME remove 0x200 if not first register /* Per error count incrementor pulse */            //
    intr_count_incr_t error_wdt_timer2_timeout_intr_count_incr_r; /* Per error count incrementor pulse */            //
    intr_count_incr_t notif_mcu_sram_ecc_cor_intr_count_incr_r;                    /* Per notification count incrementor pulse */        //
    // FIXME add back ? intr_count_incr_t notif_cmd_avail_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    // FIXME add back ? intr_count_incr_t notif_mbox_ecc_cor_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    // FIXME add back ? intr_count_incr_t notif_debug_locked_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    // FIXME add back ? intr_count_incr_t notif_scan_mode_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    // FIXME add back ? intr_count_incr_t notif_soc_req_lock_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    // FIXME add back ? intr_count_incr_t notif_gen_in_toggle_intr_count_incr_r;   /* Per notification count incrementor pulse */        //
    /* ------------------------------------------------------------------------------------------------------------- */

    /* ---- Reset assignment for Error Events ---- */
    // FIXME add back ? error_internal_intr_r.error_internal_sts     -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_internal_intr_r.error_inv_dev_sts      -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_internal_intr_r.error_cmd_fail_sts     -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_internal_intr_r.error_bad_fuse_sts     -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_internal_intr_r.error_iccm_blocked_sts -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_internal_intr_r.error_mbox_ecc_unc_sts -> resetsignal = mci_pwrgood;
    error_internal_intr_r.error_wdt_timer1_timeout_sts -> resetsignal = mci_pwrgood;
    error_internal_intr_r.error_wdt_timer2_timeout_sts -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_internal_intr_count_r.cnt          -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_inv_dev_intr_count_r.cnt           -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_cmd_fail_intr_count_r.cnt          -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_bad_fuse_intr_count_r.cnt          -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_iccm_blocked_intr_count_r.cnt      -> resetsignal = mci_pwrgood;
    // FIXME add back ? error_mbox_ecc_unc_intr_count_r.cnt      -> resetsignal = mci_pwrgood;
    error_wdt_timer1_timeout_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_wdt_timer2_timeout_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    // TODO: Use this same reset for the error incrementor pulse too?

    /* ---- Interrupt Event Dynamic Assignments ---- */
    // FIXME add back? error_internal_intr_r.error_internal_sts     -> enable = error_intr_en_r.error_internal_en;
    // FIXME add back? error_internal_intr_r.error_inv_dev_sts      -> enable = error_intr_en_r.error_inv_dev_en;
    // FIXME add back? error_internal_intr_r.error_cmd_fail_sts     -> enable = error_intr_en_r.error_cmd_fail_en;
    // FIXME add back? error_internal_intr_r.error_bad_fuse_sts     -> enable = error_intr_en_r.error_bad_fuse_en;
    // FIXME add back? error_internal_intr_r.error_iccm_blocked_sts -> enable = error_intr_en_r.error_iccm_blocked_en;
    // FIXME add back? error_internal_intr_r.error_mbox_ecc_unc_sts -> enable = error_intr_en_r.error_mbox_ecc_unc_en;
    error_internal_intr_r.error_wdt_timer1_timeout_sts -> enable = error_intr_en_r.error_wdt_timer1_timeout_en;
    error_internal_intr_r.error_wdt_timer2_timeout_sts -> enable = error_intr_en_r.error_wdt_timer2_timeout_en;
    notif_internal_intr_r.notif_mcu_sram_ecc_cor_sts     -> enable = notif_intr_en_r.notif_mcu_sram_ecc_cor_en;
    // FIXME add back? notif_internal_intr_r.notif_cmd_avail_sts     -> enable = notif_intr_en_r.notif_cmd_avail_en;
    // FIXME add back? notif_internal_intr_r.notif_mbox_ecc_cor_sts  -> enable = notif_intr_en_r.notif_mbox_ecc_cor_en;
    // FIXME add back? notif_internal_intr_r.notif_debug_locked_sts  -> enable = notif_intr_en_r.notif_debug_locked_en;
    // FIXME add back? notif_internal_intr_r.notif_scan_mode_sts     -> enable = notif_intr_en_r.notif_scan_mode_en;
    // FIXME add back? notif_internal_intr_r.notif_soc_req_lock_sts  -> enable = notif_intr_en_r.notif_soc_req_lock_en;
    // FIXME add back? notif_internal_intr_r.notif_gen_in_toggle_sts -> enable = notif_intr_en_r.notif_gen_in_toggle_en;

    // FIXME add back? error_internal_intr_r.error_internal_sts     -> next   = error_intr_trig_r.error_internal_trig;
    // FIXME add back? error_internal_intr_r.error_inv_dev_sts      -> next   = error_intr_trig_r.error_inv_dev_trig;
    // FIXME add back? error_internal_intr_r.error_cmd_fail_sts     -> next   = error_intr_trig_r.error_cmd_fail_trig;
    // FIXME add back? error_internal_intr_r.error_bad_fuse_sts     -> next   = error_intr_trig_r.error_bad_fuse_trig;
    // FIXME add back? error_internal_intr_r.error_iccm_blocked_sts -> next   = error_intr_trig_r.error_iccm_blocked_trig;
    // FIXME add back? error_internal_intr_r.error_mbox_ecc_unc_sts -> next   = error_intr_trig_r.error_mbox_ecc_unc_trig;
    error_internal_intr_r.error_wdt_timer1_timeout_sts -> next   = error_intr_trig_r.error_wdt_timer1_timeout_trig;
    error_internal_intr_r.error_wdt_timer2_timeout_sts -> next   = error_intr_trig_r.error_wdt_timer2_timeout_trig;
    notif_internal_intr_r.notif_mcu_sram_ecc_cor_sts     -> next   = notif_intr_trig_r.notif_mcu_sram_ecc_cor_trig;
    // FIXME add back? notif_internal_intr_r.notif_cmd_avail_sts     -> next   = notif_intr_trig_r.notif_cmd_avail_trig;
    // FIXME add back? notif_internal_intr_r.notif_mbox_ecc_cor_sts  -> next   = notif_intr_trig_r.notif_mbox_ecc_cor_trig;
    // FIXME add back? notif_internal_intr_r.notif_debug_locked_sts  -> next   = notif_intr_trig_r.notif_debug_locked_trig;
    // FIXME add back? notif_internal_intr_r.notif_scan_mode_sts     -> next   = notif_intr_trig_r.notif_scan_mode_trig;
    // FIXME add back? notif_internal_intr_r.notif_soc_req_lock_sts  -> next   = notif_intr_trig_r.notif_soc_req_lock_trig;
    // FIXME add back? notif_internal_intr_r.notif_gen_in_toggle_sts -> next   = notif_intr_trig_r.notif_gen_in_toggle_trig;

    // NOTE: hwset for events is implicitly defined as module input

    /* ---- Global Interrupt Dynamic Assignments ---- */
    error_global_intr_r.agg_sts -> enable = global_intr_en_r.error_en;
    notif_global_intr_r.agg_sts -> enable = global_intr_en_r.notif_en;

    error_global_intr_r.agg_sts -> next = error_internal_intr_r -> intr;
    notif_global_intr_r.agg_sts -> next = notif_internal_intr_r -> intr;

    /* ---- Event Statistics Tracker Assignments ---- */
    // NOTE: This method relies upon a "counter" that is set using the
    //       same events that trigger an interrupt, then immediately
    //       self-clearing, which results in a pulse. Must be configured
    //       to be sensitive to the interrupt trigger events for each event.
    //       The output pulse is then used to increment the ACTUAL counter
    // FIXME Add back ?? error_internal_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_internal_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back ?? error_internal_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_internal_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back ?? error_internal_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_internal_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back ?? error_internal_intr_count_incr_r.pulse -> decr     = error_internal_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back ?? error_internal_intr_count_r.cnt        -> incr     = error_internal_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back ?? error_inv_dev_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_inv_dev_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back ?? error_inv_dev_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_inv_dev_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back ?? error_inv_dev_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_inv_dev_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back ?? error_inv_dev_intr_count_incr_r.pulse -> decr     = error_inv_dev_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back ?? error_inv_dev_intr_count_r.cnt        -> incr     = error_inv_dev_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back ?? error_cmd_fail_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_cmd_fail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back ?? error_cmd_fail_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_cmd_fail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back ?? error_cmd_fail_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_cmd_fail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back ?? error_cmd_fail_intr_count_incr_r.pulse -> decr     = error_cmd_fail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back ?? error_cmd_fail_intr_count_r.cnt        -> incr     = error_cmd_fail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back ?? error_bad_fuse_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_bad_fuse_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back ?? error_bad_fuse_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_bad_fuse_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back ?? error_bad_fuse_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_bad_fuse_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back ?? error_bad_fuse_intr_count_incr_r.pulse -> decr     = error_bad_fuse_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back ?? error_bad_fuse_intr_count_r.cnt        -> incr     = error_bad_fuse_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back ?? error_iccm_blocked_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_iccm_blocked_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back ?? error_iccm_blocked_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_iccm_blocked_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back ?? error_iccm_blocked_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_iccm_blocked_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back ?? error_iccm_blocked_intr_count_incr_r.pulse -> decr     = error_iccm_blocked_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back ?? error_iccm_blocked_intr_count_r.cnt        -> incr     = error_iccm_blocked_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back ?? error_mbox_ecc_unc_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_mbox_ecc_unc_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back ?? error_mbox_ecc_unc_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_mbox_ecc_unc_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back ?? error_mbox_ecc_unc_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_mbox_ecc_unc_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back ?? error_mbox_ecc_unc_intr_count_incr_r.pulse -> decr     = error_mbox_ecc_unc_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back ?? error_mbox_ecc_unc_intr_count_r.cnt        -> incr     = error_mbox_ecc_unc_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_wdt_timer1_timeout_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_wdt_timer1_timeout_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_wdt_timer1_timeout_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> decr     = error_wdt_timer1_timeout_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_wdt_timer1_timeout_intr_count_r.cnt        -> incr     = error_wdt_timer1_timeout_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> hwset    = error_internal_intr_r.error_wdt_timer2_timeout_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> next     = error_internal_intr_r.error_wdt_timer2_timeout_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> we       = error_internal_intr_r.error_wdt_timer2_timeout_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> decr     = error_wdt_timer2_timeout_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_wdt_timer2_timeout_intr_count_r.cnt        -> incr     = error_wdt_timer2_timeout_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> hwset    = notif_internal_intr_r.notif_mcu_sram_ecc_cor_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> next     = notif_internal_intr_r.notif_mcu_sram_ecc_cor_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> we       = notif_internal_intr_r.notif_mcu_sram_ecc_cor_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> decr     = notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mcu_sram_ecc_cor_intr_count_r.cnt        -> incr     = notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit
    
    // FIXME Add back??? notif_cmd_avail_intr_count_incr_r.pulse -> hwset    = notif_internal_intr_r.notif_cmd_avail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back??? notif_cmd_avail_intr_count_incr_r.pulse -> next     = notif_internal_intr_r.notif_cmd_avail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back??? notif_cmd_avail_intr_count_incr_r.pulse -> we       = notif_internal_intr_r.notif_cmd_avail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back??? notif_cmd_avail_intr_count_incr_r.pulse -> decr     = notif_cmd_avail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back??? notif_cmd_avail_intr_count_r.cnt        -> incr     = notif_cmd_avail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back??? notif_mbox_ecc_cor_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_mbox_ecc_cor_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back??? notif_mbox_ecc_cor_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_mbox_ecc_cor_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back??? notif_mbox_ecc_cor_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_mbox_ecc_cor_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back??? notif_mbox_ecc_cor_intr_count_incr_r.pulse -> decr  = notif_mbox_ecc_cor_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back??? notif_mbox_ecc_cor_intr_count_r.cnt        -> incr  = notif_mbox_ecc_cor_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back??? notif_debug_locked_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_debug_locked_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back??? notif_debug_locked_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_debug_locked_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back??? notif_debug_locked_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_debug_locked_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back??? notif_debug_locked_intr_count_incr_r.pulse -> decr  = notif_debug_locked_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back??? notif_debug_locked_intr_count_r.cnt        -> incr  = notif_debug_locked_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back??? notif_scan_mode_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_scan_mode_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back??? notif_scan_mode_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_scan_mode_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back??? notif_scan_mode_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_scan_mode_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back??? notif_scan_mode_intr_count_incr_r.pulse -> decr  = notif_scan_mode_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back??? notif_scan_mode_intr_count_r.cnt        -> incr  = notif_scan_mode_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back??? notif_soc_req_lock_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_soc_req_lock_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back??? notif_soc_req_lock_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_soc_req_lock_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back??? notif_soc_req_lock_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_soc_req_lock_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back??? notif_soc_req_lock_intr_count_incr_r.pulse -> decr  = notif_soc_req_lock_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back??? notif_soc_req_lock_intr_count_r.cnt        -> incr  = notif_soc_req_lock_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    // FIXME Add back??? notif_gen_in_toggle_intr_count_incr_r.pulse -> hwset = notif_internal_intr_r.notif_gen_in_toggle_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    // FIXME Add back??? notif_gen_in_toggle_intr_count_incr_r.pulse -> next  = notif_internal_intr_r.notif_gen_in_toggle_sts -> next;  // /      as a pulse to increment the intr_count_r register
    // FIXME Add back??? notif_gen_in_toggle_intr_count_incr_r.pulse -> we    = notif_internal_intr_r.notif_gen_in_toggle_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    // FIXME Add back??? notif_gen_in_toggle_intr_count_incr_r.pulse -> decr  = notif_gen_in_toggle_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    // FIXME Add back??? notif_gen_in_toggle_intr_count_r.cnt        -> incr  = notif_gen_in_toggle_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit


};

/* -----------------------
 * Register File instance
 * ----------------------- */
intr_block_t intr_block_rf @0x1000;
};
