// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
////////////////////////////////////////////////////////////////
// MCI Registers
addrmap mci_reg {

    ////////////////////////////////////////////////////////////////
    // Properties
    desc="Address map for Manufacturer Control Interface Block architectural registers";

    addressing = regalign; // This is the default if not specified
    lsb0 = true; // lsb0 property is implicit/default. See docs for
                 // SystemRDL 2.0 sections 9.1 and 13.4
    littleendian = true;

    default hw = na;
    signal {activelow; async; cpuif_reset; field_reset;} mci_rst_b;
    signal {activelow; async;} mci_pwrgood;

    // AXI Request Signals
    signal {
        desc = "Asserted when a there is a valid AXI request from MCU.";
    } axi_mcu_req;
    
    // SS_CONFIG_DONE Signals
    signal {
        desc = "Indicates when SS configuration is unlocked, inverse of SS_CONFIG_DONE.";
    } ss_config_unlock;
    signal {
        desc = "Indicates when SS sticky configuration is unlocked, inverse of SS_CONFIG_DONE_STICKY.";
    } ss_config_unlock_sticky;
    
    // Capabilities Lock Signals
    signal {
        desc = "Indicates when there is a valid AXI request from MCU or SoC Config Agent AND the CAP_LOCK register is not set";
    } axi_mcu_req_or_mci_soc_config_req__cap_unlock;
    
    signal {
        desc = "Indicates when there is a valid AXI request from MCU or the SoC Config Agent.";
    } axi_mcu_or_mcu_sram_config_req;
    
    // AXI Request + SS_CONFIG_DONE Signals
    signal {
        desc = "Indicates when there is a valid AXI request from MCU or the SoC Config Agent.";
    } axi_mcu_or_mci_soc_config_req;
    signal {
        desc = "Indicates when there is a valid AXI request from MCU or the SoC Config Agent AND the SS configuration is unlocked, inverse of SS_CONFIG_DONE.";
    } axi_mcu_or_mci_soc_config_req__ss_config_unlock;
    signal {
        desc = "Indicates when there is a valid AXI request from MCU or the SoC Config Agent AND the SS configuration is unlocked, inverse of SS_CONFIG_DONE_STICKY.";
    } axi_mcu_or_mci_soc_config_req__ss_config_unlock_sticky;

    //defined fields by access type
    field rw_ro_ro_hw {swwe = axi_mcu_or_mci_soc_config_req; hw = r;}; //writes enabled only for MCU, hw readable
    field rw_rw_sticky_hw { sw=rw; hw=rw; we=true; woclr = true; resetsignal = mci_pwrgood;}; //W1C            - used by HW ERROR regs
    field rw_rw_sticky    { sw=rw; hw=rw; we=true; swmod = true; resetsignal = mci_pwrgood;}; //writes enabled - used by FW ERROR regs

    ////////////////////////////////////////////////////////////////
    // Registers

    // ----------------------------------------
    // ------------ IDENTIFICATION ------------
    reg {
        name = "Manufacturer Control Interface HW Capabilities";
        desc = "MCU HW Capabilities. Initialized with reset values, rewritable by MCU FW.
                [br]Read-only once locked.";
        field {sw=rw; swwe=axi_mcu_req_or_mci_soc_config_req__cap_unlock; resetsignal=mci_rst_b;} cap[32]=32'h0;
    } HW_CAPABILITIES;
    reg {
        name = "Manufacturer Control Interface FW Capabilities";
        desc = "MCU FW Capabilities. Initialized with reset values. rewrtitable by MCU FW.
                [br]Read-only once locked.";
        field {sw=rw; swwe=axi_mcu_req_or_mci_soc_config_req__cap_unlock; resetsignal=mci_rst_b;} cap[32]=32'h0; 
    } FW_CAPABILITIES;
    reg {
        name = "MCI Capabilities Lock";
        desc = "Lock register to disable further firmware modifications to capabilities registers.
                [br]Once set, this register may not be cleared until a warm reset. If set, the values in HW_CAPABILITIES and FW_CAPABILITIES may not be modified.
                [br]Read-only once locked.";
        field {sw=rw; hw=r; swwe=axi_mcu_req_or_mci_soc_config_req__cap_unlock; resetsignal=mci_rst_b;} lock = 1'b0;
    } CAP_LOCK;

    reg {
        name = "MCI/MCU HW RevID";
        desc = "HW revision ID for Manufacturer Control components (MCU & MCI) that matches the official
                final release milestone of Caliptra Subsystem.";
        field {desc = "Official release version. Bit field encoding is:
                       [br][lb]15:12[rb] Major version
                       [br][lb]11: 8[rb] Minor version
                       [br][lb] 7: 0[rb] Patch version";
               sw=r;} MC_GENERATION[16]=0x1000;
    } HW_REV_ID;
    reg {
        name = "MCU FW RevID";
        desc = "MCU FW revision ID";
        field {sw=rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b;} REV_ID[32]=0;
    } FW_REV_ID[2];
    reg {
        name = "MCU HW Config";
        desc = "MCU HW Configuration
                ";
        // No storage, i.e. no resetsignal
        field {desc = "MCU MBOX1 SRAM SIZE KB. If 0 there is no mailbox"; hw=w; sw=r;} MCU_MBOX1_SRAM_SIZE[12];
        field {desc = "MCU MBOX0 SRAM SIZE KB. If 0 there is no mailbox"; hw=w; sw=r;} MCU_MBOX0_SRAM_SIZE[12];
    } HW_CONFIG0;
    reg {
        name = "MCU HW Config";
        desc = "MCU HW Configuration";
        // No storage, i.e. no resetsignal
        field {desc = "Size of MCU reset counter"; hw=w; sw=r;} MIN_MCU_RST_COUNTER_WIDTH[5];
        field {desc = "MCU SRAM Size KB"; hw=w; sw=r;} MCU_SRAM_SIZE[12];
    } HW_CONFIG1;
    
    reg {
        name = "MCU IFU AXI USER";
        desc = "MCU IFU AXI USER Strap";
        // No storage, i.e. no resetsignal
        field {hw=w; sw=r;} value[32];
    } MCU_IFU_AXI_USER;
    
    reg {
        name = "MCU LSU AXI USER";
        desc = "MCU LSU AXI USER Strap";
        // No storage, i.e. no resetsignal
        field { hw=w; sw=r;} value[32];
    } MCU_LSU_AXI_USER;
    
    reg {
        name = "MCU SRAM CONFIG AGENT AXI USER";
        desc = "Agent with access to MCU SRAM Execution region. Typically Caliptra Core";
        // No storage, i.e. no resetsignal
        field { hw=w; sw=r;} value[32];
    } MCU_SRAM_CONFIG_AXI_USER;
    
    reg {
        name = "MCI SOC CONFIG AGENT AXI USER";
        desc = "SOC agent with special access to MCI register bank";
        // No storage, i.e. no resetsignal
        field { hw=w; sw=r;} value[32];
    } MCI_SOC_CONFIG_AXI_USER;

    // ----------------------------------------
    // ---------------- STATUS ----------------
    reg {
        name = "FW Flow Status";
        desc = "Reports the status of the firmware flows.
                [br]TAP Access [with debug intent set]: RO";
        field {swwe = axi_mcu_or_mci_soc_config_req; hw=r; resetsignal = mci_rst_b;} status[32]=0;
    } FW_FLOW_STATUS @0x30;
    reg {
        name = "Flow Status";
        desc = "Reports the status of HW FSMs and other flows.
                [br]TAP Access [with debug intent set]: RO";
        field {desc="MCI Boot FSM State";                                            sw=r;                  hw=rw ; /* no storage, no reset */} boot_fsm[4];
    } HW_FLOW_STATUS;



    reg {
        name = "Reset Reason";
        desc = "Indicates to ROM the originating cause for the PC to be reset to 0.
                Firmware Update Reset indicator is reset by the warm reset and updated by SW applying MCU FW updated.
                Warm Reset indicator is reset by the cold reset.
                [br]TAP Access [with debug intent set]: RO";
        field {desc = "FW update reset has been executed for the second+ time since MCI reset"; swwe = axi_mcu_or_mcu_sram_config_req; sw=rw; hw=r; resetsignal = mci_rst_b;  } FW_HITLESS_UPD_RESET=0;
        field {desc = "FW update reset has been executed first time since MCI reset";swwe = axi_mcu_or_mcu_sram_config_req;  sw=rw; hw=r; resetsignal = mci_rst_b;  } FW_BOOT_UPD_RESET=0;
        field {desc = "Warm reset has been executed";  swwe = axi_mcu_or_mcu_sram_config_req;    sw=rw; hw=rw; we;          resetsignal = mci_pwrgood;} WARM_RESET=0;
    } RESET_REASON;

    reg {
        name = "Reset Status";
        desc = "Reports the status of the rests controlled by MCI.
                [br]TAP Access [with debug intent set]: RO";
        field {desc="caliptra reset status. 1: Reset asserted. 0: Reset deasserted";    sw=r;  hw=rw ;} cptra_reset_sts=0;
        field {desc="MCU reset status. 1: Reset asserted. 0: Reset deasserted";         sw=r;  hw=rw ;} mcu_reset_sts=0;
    } RESET_STATUS;

    reg {
        name = "Security State";
        desc = "Indicates current hardware security state.";
        enum device_lifecycle_e {
            DEVICE_UNPROVISIONED = 2'b00 {
                desc = "Unprovisioned";
            };
            DEVICE_MANUFACTURING = 2'b01 {
                desc = "Manufacturing";
            };
            DEVICE_PRODUCTION    = 2'b11 {
                desc = "Production";
            };
        };  
        field {desc = "Device Lifecycle"; sw=r; hw=w; encode = device_lifecycle_e; resetsignal = mci_rst_b;} device_lifecycle[2]=0;
        field {desc = "Debug Locked"    ; sw=r; hw=w;                              resetsignal = mci_rst_b;} debug_locked=0;
        field {desc = "scan mode signal observed at caliptra interface - only for debug mode as its used to flush assets - 
                       when truly in scan mode, everything will be BROKEN for functional reads!"; 
                                          sw=r; hw=w;                              resetsignal = mci_rst_b;} scan_mode=0;
    } SECURITY_STATE;
   

    // ----------------------------------------
    // ---------------- ERROR -----------------
    reg {
        name = "Hardware Error Fatal";
        desc = "Indicates fatal hardware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, clearing
                the bit in this register will not cause the interrupt to deassert.
                Only an MCI reset will clear the fatal error interrupt.
                [br]AXI Access:      RW1C
                [br]TAP Access [with debug intent set]: RO";
        rw_rw_sticky_hw mcu_sram_ecc_unc=1'b0;  /* Uncorrectable double-bit error in MCU SRAM */
        rw_rw_sticky_hw nmi_pin=1'b0;           /* Non-Maskable Interrupt due to WDT timeout */
        rw_rw_sticky_hw mcu_sram_dmi_axi_collision=1'b0;  /* Collision between AXI and DMI MCU SRAM. No what data is in SRAM */
    } HW_ERROR_FATAL @0x50;
    reg {
        name = "Aggregate Error Fatal";
        desc = "Indicates fatal error from another IP within Caliptra SS. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, clearing
                the bit in this register will not cause the interrupt to deassert.
                Only an MCI reset will clear the fatal error interrupt.
                [br] 5:0 -- caliptra core fatal errors
                [br] {5'b0, cptra_error_fatal}
                [br] 11:6 - mcu fatal errors
                [br] {5'b0, mcu_dccm_ecc_double_error}
                [br] 17:12 -- lcc alerts
                [br] {3'b0, fatal_bus_integ_error, fatal_state_error, fatal_prog_error}
                [br] 23:18 -- otp fc alerts
                [br] {1'b0, recov_prim_otp_alert, fatal_prim_otp_alert, fatal_bus_integ_error, fatal_check_error, fatal_macro_error}
                [br] 29:24 -- I3C - masked by default, unmasked in non_fatal error register
                [br] {4'b0, i3c_peripheral_reset, i3c_escalated_reset}
                [br] 31:30 -- spare bits
                [br]AXI Access: RW1C
                [br]TAP Access [with debug intent set]: RO";
        rw_rw_sticky_hw agg_error_fatal31 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal30 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal29 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal28 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal27 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal26 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal25 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal24 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal23 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal22 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal21 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal20 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal19 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal18 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal17 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal16 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal15 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal14 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal13 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal12 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal11 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal10 = 1'b0;
        rw_rw_sticky_hw agg_error_fatal9  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal8  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal7  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal6  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal5  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal4  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal3  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal2  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal1  = 1'b0;
        rw_rw_sticky_hw agg_error_fatal0  = 1'b0;
    } AGG_ERROR_FATAL;
    reg {
        name = "Hardware Error Non-Fatal";
        desc = "Indicates non-fatal hardware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_non_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, any
                change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] AGG_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] agg_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask 
                [/list]
                [br]AXI Access:      RW1C
                [br]TAP Access [with debug intent set]: RO";
        rw_rw_sticky_hw mbox0_ecc_unc=0;      /* Uncorrectable double-bit error in MBOX0 */
        rw_rw_sticky_hw mbox1_ecc_unc=0;      /* Uncorrectable double-bit error in MBOX1 */

    } HW_ERROR_NON_FATAL;
    reg {
        name = "Aggregate Error Non-Fatal";
        desc = "Indicates non-fatal error from another IP within the Caliptra SS. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_non_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, any
                change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br] 5:0 -- caliptra core non fatal errors
                [br] {5'b0, cptra_error_non_fatal}
                [br] 11:6 - mcu non fatal errors
                [br] {5'b0, mcu_dccm_ecc_single_error}
                [br] 17:12 -- lcc alerts - masked by default, unmasked in fatal error register
                [br] {3'b0, fatal_bus_integ_error, fatal_state_error, fatal_prog_error}
                [br] 23:18 -- otp fc alerts - masked by default, unmasked in fatal error register
                [br] {1'b0, recov_prim_otp_alert, fatal_prim_otp_alert, fatal_bus_integ_error, fatal_check_error, fatal_macro_error}
                [br] 29:24 -- I3C
                [br] {4'b0, i3c_peripheral_reset, i3c_escalated_reset}
                [br] 31:30 -- spare bits
                [br]AXI Access:      RW1C
                [br]TAP Access [with debug intent set]: RO";
        rw_rw_sticky_hw agg_error_non_fatal31 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal30 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal29 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal28 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal27 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal26 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal25 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal24 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal23 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal22 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal21 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal20 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal19 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal18 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal17 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal16 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal15 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal14 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal13 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal12 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal11 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal10 = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal9  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal8  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal7  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal6  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal5  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal4  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal3  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal2  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal1  = 1'b0;
        rw_rw_sticky_hw agg_error_non_fatal0  = 1'b0;
    } AGG_ERROR_NON_FATAL;
    reg {
        name = "Firmware Error Fatal";
        desc = "Indicates fatal firmware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, clearing
                the bit in this register will not cause the interrupt to deassert.
                Only an MCI reset will clear the fatal error interrupt.
                [br]TAP Access [with debug intent set]: RO";
        rw_rw_sticky error_code[32]=0; 
    } FW_ERROR_FATAL;
    reg {
        name = "Firmware Error Non-Fatal";
        desc = "Indicates non-fatal firmware error. Assertion of any bit in this
                register results in the assertion of the SoC interrupt pin,
                mci_error_non_fatal, unless that bit is masked using the internal
                mask register. After the output interrupt is asserted, any
                change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] AGG_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] agg_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask 
                [/list]
                [br]TAP Access [with debug intent set]: RO";
        rw_rw_sticky error_code[32]=0; 
    } FW_ERROR_NON_FATAL;
    reg {
        name = "Hardware Error Encoding";
        desc = "Encoded error value for hardware errors.
                [br]TAP Access [with debug intent set]: RO";
         field {resetsignal = mci_pwrgood; sw=rw; hw=r;}error_code[32]=0; 
    } HW_ERROR_ENC;
    reg {
        name = "Firmware Error Encoding";
        desc = "Encoded error value for firmware errors.
                [br]TAP Access [with debug intent set]: RO";
        field {resetsignal = mci_pwrgood; sw=rw; hw=r;} error_code[32]=0; 
    } FW_ERROR_ENC;
    reg {
        name = "Firmware Extended Error Information";
        desc = "Firmware Extended Error information for firmware errors.
                [br]TAP Access [with debug intent set]: RO";
        field {resetsignal = mci_pwrgood;sw=rw; hw=r;} error_info[32]=0; 
    } FW_EXTENDED_ERROR_INFO[8];

    reg {
        name = "Hardware Error Fatal Mask";
        desc = "Bit mask for the register HW_ERROR_FATAL to determine
                which bits are disabled for interrupt generation on the
                mci_error_fatal output signal.
                [br]A value of 1 in a field of this register means the corresponding bit
                position in HW_ERROR_FATAL will not produce an interrupt
                output assertion. If a hardware error bit is set and was previously
                masked, and firmware performs a write to clear the corresponding mask
                bit in this register, the interrupt output will not be asserted. Only
                the same error condition reoccurring while it is unmasked will cause
                a new assertion of the interrupt output.
                [br]Firmware can not cause the interrupt output to deassert by setting
                mask bits for fatal error conditions that have already triggered the 
                interrupt.";
        rw_ro_ro_hw mask_mcu_sram_ecc_unc=1'b0;  /* Uncorrectable double-bit error in MCU SRAM */
        rw_ro_ro_hw mask_nmi_pin=1'b0;           /* Non-Maskable Interrupt due to WDT timeout */
        rw_ro_ro_hw mask_mcu_sram_dmi_axi_collision=1'b0;  /* Collision between AXI and DMI MCU SRAM. No what data is in SRAM */
    } internal_hw_error_fatal_mask;
    reg {
        name = "Hardware Error Non-Fatal Mask";
        desc = "Bit mask for the register HW_ERROR_NON_FATAL to determine
                which bits are disabled for interrupt generation on the
                mci_error_non_fatal output signal.
                [br]A value of 1 in a field of this register means the corresponding bit
                position in HW_ERROR_NON_FATAL will not produce an interrupt
                output assertion. If a hardware error bit is set that was previously
                masked, and firmware performs a write to clear the corresponding mask
                bit in this register, the interrupt output will not be asserted. Only
                the same error condition reoccurring while it is unmasked will cause
                a new assertion of the interrupt output.
                [br]Any change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] AGG_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] agg_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask 
                [/list]";
        rw_ro_ro_hw mask_mbox0_ecc_unc=0;      /* Uncorrectable double-bit error in DCCM */
        rw_ro_ro_hw mask_mbox1_ecc_unc=0;      /* Uncorrectable double-bit error in DCCM */
    } internal_hw_error_non_fatal_mask;
    reg {
        name = "Aggregate Error Fatal Mask";
        desc = "Bit mask for the register AGG_ERROR_FATAL to determine
                which bits are disabled for interrupt generation on the
                mci_error_fatal output signal.
                [br]A value of 1 in a field of this register means the corresponding bit
                position in AGG_ERROR_FATAL will not produce an interrupt
                output assertion. If a hardware error bit is set and was previously
                masked, and firmware performs a write to clear the corresponding mask
                bit in this register, the interrupt output will not be asserted. Only
                the same error condition reoccurring while it is unmasked will cause
                a new assertion of the interrupt output.
                [br]Firmware can not cause the interrupt output to deassert by setting
                mask bits for fatal error conditions that have already triggered the 
                interrupt.";
        rw_ro_ro_hw mask_agg_error_fatal31 = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal30 = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal29 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal28 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal27 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal26 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal25 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal24 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal23 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal22 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal21 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal20 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal19 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal18 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal17 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal16 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal15 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal14 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal13 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal12 = 1'b1;
        rw_ro_ro_hw mask_agg_error_fatal11 = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal10 = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal9  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal8  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal7  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal6  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal5  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal4  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal3  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal2  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal1  = 1'b0;
        rw_ro_ro_hw mask_agg_error_fatal0  = 1'b0;
    } internal_agg_error_fatal_mask;
    reg {
        name = "Aggregate Error Non-Fatal Mask";
        desc = "Bit mask for the register AGG_ERROR_NON_FATAL to determine
                which bits are disabled for interrupt generation on the
                mci_error_non_fatal output signal.
                [br]A value of 1 in a field of this register means the corresponding bit
                position in AGG_ERROR_NON_FATAL will not produce an interrupt
                output assertion. If a hardware error bit is set that was previously
                masked, and firmware performs a write to clear the corresponding mask
                bit in this register, the interrupt output will not be asserted. Only
                the same error condition reoccurring while it is unmasked will cause
                a new assertion of the interrupt output.
                [br]Any change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] AGG_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] agg_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask 
                [/list]";
        rw_ro_ro_hw mask_agg_error_non_fatal31 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal30 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal29 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal28 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal27 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal26 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal25 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal24 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal23 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal22 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal21 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal20 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal19 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal18 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal17 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal16 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal15 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal14 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal13 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal12 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal11 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal10 = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal9  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal8  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal7  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal6  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal5  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal4  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal3  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal2  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal1  = 1'b0;
        rw_ro_ro_hw mask_agg_error_non_fatal0  = 1'b0;
    } internal_agg_error_non_fatal_mask;
    reg {
        name = "Firmware Error Fatal Mask";
        desc = "Bit mask for the register FW_ERROR_FATAL to determine
                which bits are disabled for interrupt generation on the
                mci_error_fatal output signal.
                [br]A value of 1 in a field of this register means the corresponding bit
                position in FW_ERROR_FATAL will not produce an interrupt
                output assertion. If a firmware error bit is set and was previously
                masked, and firmware performs a write to clear the corresponding mask
                bit in this register, the interrupt output will not be asserted. Only
                the same error bit being cleared then set again while it is unmasked will cause
                a new assertion of the interrupt output.
                [br]Firmware can not cause the interrupt output to deassert by setting
                mask bits for fatal error conditions that have already triggered the 
                interrupt.";
        rw_ro_ro_hw mask[32]=0; 
    } internal_fw_error_fatal_mask;
    reg {
        name = "Firmware Error Non-Fatal Mask";
        desc = "Bit mask for the register FW_ERROR_NON_FATAL to determine
                which bits are disabled for interrupt generation on the
                mci_error_non_fatal output signal.
                [br]A value of 1 in a field of this register means the corresponding bit
                position in FW_ERROR_NON_FATAL will not produce an interrupt
                output assertion. If a firmware error bit is set that was previously
                masked, and firmware performs a write to clear the corresponding mask
                bit in this register, the interrupt output will not be asserted. Only
                the same error bit being cleared then set again while it is unmasked will cause
                a new assertion of the interrupt output.
                [br]Any change by firmware that results in all set non-fatal errors
                being masked will immediately deassert the interrupt output. This means
                that firmware may cause the mci_error_non_fatal signal to deassert by
                writing to any of these registers, if the write results in all error
                bits being cleared or masked:
                [br][list]
                [br] [*] HW_ERROR_NON_FATAL
                [br] [*] AGG_ERROR_NON_FATAL
                [br] [*] FW_ERROR_NON_FATAL
                [br] [*] hw_error_non_fatal_mask
                [br] [*] agg_error_non_fatal_mask
                [br] [*] fw_error_non_fatal_mask 
                [/list]";
        rw_ro_ro_hw mask[32]=0; 
    } internal_fw_error_non_fatal_mask;

    // ----------------------------------------
    // ----------------- WDT ------------------
    //Timer1
    reg {
        name = "WDT Timer1 EN register";
        desc = "Watchdog timer1 enable register";
        field {desc = "WDT timer1 enable"; hw = r; sw = rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b;} timer1_en = 1'b0;
    } WDT_TIMER1_EN @0xB0;

    reg {
        name = "WDT Timer1 CTRL register";
        desc = "Watchdog timer1 control register";
        field {desc = "WDT timer1 restart"; hw = r; sw = rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b; singlepulse;} timer1_restart = 1'b0;
    } WDT_TIMER1_CTRL;

    reg {
        name = "WDT Timer1 Timeout Period register";
        desc = "Watchdog timer1 timeout register";
        field {desc = "WDT timer1 timeout period"; hw = r; sw = rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b;} timer1_timeout_period[32] = 32'hFFFFFFFF;
    } WDT_TIMER1_TIMEOUT_PERIOD[2]; // This reflects WDT_TIMEOUT_PERIOD_NUM_DWORDS in mci_pkg.sv

    //Timer2
    reg {
        name = "WDT Timer2 EN register";
        desc = "Watchdog timer2 enable register. Note: Setting this to 1 will disable the default cascaded mode and will have both timers count independently.";
        field {desc = "WDT timer2 enable"; hw = r; sw = rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b;} timer2_en = 1'b0;
    } WDT_TIMER2_EN;

    reg {
        name = "WDT Timer2 CTRL register";
        desc = "Watchdog timer2 control register";
        field {desc = "WDT timer2 restart"; hw = r; sw = rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b; singlepulse;} timer2_restart = 1'b0;
    } WDT_TIMER2_CTRL;

    reg {
        name = "WDT Timer2 Timeout Period register";
        desc = "Watchdog timer2 timeout register";
        field {desc = "WDT timer2 timeout period"; hw = r; sw = rw; swwe = axi_mcu_or_mci_soc_config_req; resetsignal = mci_rst_b;} timer2_timeout_period[32] = 32'hFFFFFFFF;
    } WDT_TIMER2_TIMEOUT_PERIOD[2]; //This reflects WDT_TIMEOUT_PERIOD_NUM_DWORDS in mci_pkg.sv

    //Status
    reg {
        name = "WDT STATUS register";
        desc = "Watchdog timer status register";
        field {desc = "Timer1 timed out, timer2 enabled"; hw = rw; sw = r;  resetsignal = mci_rst_b;} t1_timeout = 1'b0;
        field {desc = "Timer2 timed out"; hw = rw; sw = r; resetsignal = mci_rst_b;} t2_timeout = 1'b0;
    } WDT_STATUS;

    // Req
    reg {
        name = "WDT1 Config";
        desc = "SOC provided count in cycles for WDT1 timeout.";
        field {sw=rw; hw=na; resetsignal = mci_pwrgood;} TIMEOUT[32]=0;
    } WDT_CFG[2];

    // ----------------------------------------
    // ---------------- TIMER -----------------
    reg {
        name = "Timer Config";
        desc = "Provides the clock period of the system clock.
                Used to standardize the RISC-V Standard MTIME count register.
                Clock Period is indicated as an integer number of picoseconds.";
        field {desc = "Period in (ps)"; sw=rw; hw=na; resetsignal = mci_pwrgood;} clk_period[32] = 32'h0;
    } MCU_TIMER_CONFIG @0xE0;

    reg {
        name = "mtime low";
        desc = "RISC-V Standard Machine-mode Time Counter, lower 32-bits.
                [br]Frequency of counter is indicated in MCU_TIMER_CONFIG.clk_period.";
        field {desc = "Counter Low" ; sw = rw; precedence = sw; swmod = true; hw = r; swwe = axi_mcu_req; counter = true; incrvalue = 1; overflow = true; resetsignal = mci_pwrgood;} count_l[32] = 32'h0;
    } MCU_RV_MTIME_L;

    reg {
        name = "mtime high";
        desc = "RISC-V Standard Machine-mode Time Counter, upper 32-bits.
                [br]Frequency of counter is indicated in MCU_TIMER_CONFIG.clk_period.";
        field {desc = "Counter High"; sw = rw; precedence = sw; swmod = true; hw = r; swwe = axi_mcu_req; counter = true; incrvalue = 1;                  resetsignal = mci_pwrgood;} count_h[32] = 32'h0;
    } MCU_RV_MTIME_H;

    reg {
        name = "mtimecmp low";
        desc = "RISC-V Standard Machine-mode Time Counter Compare Value, lower 32-bits.";
        field {desc = "Count Compare Low" ; sw = rw; hw = r; swwe = axi_mcu_req; resetsignal = mci_pwrgood;} compare_l[32] = 32'h0;
    } MCU_RV_MTIMECMP_L;

    reg {
        name = "mtimecmp high";
        desc = "RISC-V Standard Machine-mode Time Counter Compare Value, upper 32-bits.";
        field {desc = "Count Compare High"; sw = rw; hw = r; swwe = axi_mcu_req; resetsignal = mci_pwrgood;} compare_h[32] = 32'h0;
    } MCU_RV_MTIMECMP_H;


    // ----------------------------------------
    // ----------- RESET/BOOT MGMT ------------
    reg {
        name = "Reset Request;
                [br]TAP Access [in debug mode]: RW";
        field { desc = "Request. Writable by MCU. Causes MCU reset to be asserted by MCI. Cleared when reset is asserted."; sw=rw; hw=rw; hwclr=true; swwe=axi_mcu_or_mci_soc_config_req; resetsignal=mci_rst_b; we;} mcu_req=1'b0;
    } RESET_REQUEST @0x100;


    reg {
        name = "MCI BOOT FSM GO";
        desc = "Request MCI BootFSM to continue past the breakpoint allowing MCU and Caliptra to be brought out of reset. 
                [br]TAP Access [with debug intent set]: RW";
        field { sw=rw; hw = rw; we;} go=1'b0;
    } MCI_BOOTFSM_GO;

    reg {
        name = "Caliptra Boot Go";
        desc = "Request Caliptra Reset to be deasserted by the MCI Boot FSM. 
                [br]TAP Access [in debug mode]: RW";
        field { sw=rw; hw = rw; we;} go=1'b0;
    } CPTRA_BOOT_GO;

    reg {
        name = "Firmware SRAM Exec Region Size";
        desc = "Dynamic size assignment for the region of sram that contains executable instructions for MCU. Locked when SS_CONFIG_DONE is set.
                [br]TAP Access [in debug mode]: RW";
        field { desc="Size (in multiples of 4KiB)"; sw=rw; hw=rw; swwe=axi_mcu_or_mci_soc_config_req__ss_config_unlock; we;} size[16] = 16'h0;
    } FW_SRAM_EXEC_REGION_SIZE;
    reg {
        name = "MCU NMI Vector";
        desc = "32-bit register providing the jump vector for RISC-V to transition for NMI handling code.
                Default is the base address of ROM, but may be updated for enhanced handling by runtime images.
                Bit [0] is ignored to enforce half-word alignment of address.
                [br]TAP Access [in debug mode]: RW";
        field {desc = "NMI Vector"; hw = rw; we; sw = rw; swwe = axi_mcu_or_mci_soc_config_req__ss_config_unlock;} vec[32] = 32'h0;
    } MCU_NMI_VECTOR;

    reg {
        name = "MCU Reset Vector";
        desc = "32-bit register providing the reset vector for RISC-V do the initial fetch.
                Default is determined by a HW strap strap_mcu_reset_vector and is sampled on mci_rst_b deassertions, but may be modified by SW while in debug mode.
                Bit [0] is ignored to enforce half-word alignment of address.
                [br]TAP Access [in debug mode]: RW";
        field {desc = "NMI Vector"; hw = rw; we; sw = rw; swwe = axi_mcu_or_mci_soc_config_req__ss_config_unlock;} vec[32] = 32'h0; 
    } MCU_RESET_VECTOR;

    // ----------------------------------------
    // ------------ AxUSER CONFIG -------------
    reg {
        name = "Valid USER Registers";
         desc = "Valid AXI USER attributes for requests from SoC AXI Interface. Only valid once LOCK is set.
                 [br]Read-Only once locked by AXI_USER_LOCK.";
         field {sw=rw; hw=r; swwel;resetsignal = mci_rst_b;} AXI_USER[32]=0xFFFF_FFFF;
     } MBOX0_VALID_AXI_USER[5] @0x180;
    
    reg {
        name = "Valid USER Register Lock";
         desc = "Valid AXI_USER attributes for requests from SoC AXI Interface.
                 [br]Each bit corresponds to locking the associated MBO0X_VALID_AXI_USER register.
                 [br]Associated MBOX0_VALID_AXI_USER register is only valid once locked by this bit.
                 [br]AXI Access:      RW1-S
                 [br]Read-Only once locked.";
         field {sw=rw; hw=r; swwel; resetsignal = mci_rst_b;} LOCK=0;
     } MBOX0_AXI_USER_LOCK[5] @0x1A0;

    reg {
        name = "Valid USER Registers";
         desc = "Valid AXI USER attributes for requests from SoC AXI Interface. Only valid once LOCK is set.
                 [br]Read-Only once locked by AXI_USER_LOCK.";
         field {sw=rw; hw=r; swwel;resetsignal = mci_rst_b;} AXI_USER[32]=0xFFFF_FFFF;
     } MBOX1_VALID_AXI_USER[5] @0x1C0;
    
    reg {
        name = "Valid USER Register Lock";
         desc = "Valid AXI_USER attributes for requests from SoC AXI Interface.
                 [br]Each bit corresponds to locking the associated MBO0X_VALID_AXI_USER register.
                 [br]Associated MBOX0_VALID_AXI_USER register is only valid once locked by this bit.
                 [br]AXI Access:      RW1-S
                 [br]Read-Only once locked.";
         field {sw=rw; hw=r; swwel; resetsignal = mci_rst_b;} LOCK=0;
     } MBOX1_AXI_USER_LOCK[5] @0x1E0;


    // ----------------------------------------
    // ------------ LCC GASKET ----------------
    
    reg {
        name = "SOC DFT Enable Mask";
         desc = "Masks Caliptra's SS_SOC_DBG_UNLOCK_LEVEL to enable DFT for the SOC. 
                 [br]If a MASK bit is set along with a corresponding bit in SS_DOC_DBG_UNLOCK, SOC_DFT_EN will be enabled.
                 [br]Otherwise SOC_DFT_EN can only be set via LCC.";
         field {sw=rw; hw=r; resetsignal = mci_pwrgood;swwe = axi_mcu_or_mci_soc_config_req__ss_config_unlock_sticky;} MASK[32]=0;
     } SOC_DFT_EN[2] @0x300;
    
    reg {
        name = "SOC HW Debug Enable Mask";
         desc = "Masks Caliptra's SS_SOC_DBG_UNLOCK_LEVEL to enable HW Debug for the SOC. 
                 [br]If a MASK bit is set along with a corresponding bit in SS_DOC_DBG_UNLOCK, SOC_HW_DEBUG_EN will be enabled.
                 [br]Otherwise SOC_HW_DEBUG_EN can only be set via LCC.";
         field {sw=rw; hw=r; resetsignal = mci_pwrgood;swwe = axi_mcu_or_mci_soc_config_req__ss_config_unlock_sticky;} MASK[32]=0;
     } SOC_HW_DEBUG_EN[2];
    
    reg {
        name = "SOC Poduction Debug State Mask";
         desc = "Masks Caliptra's SS_SOC_DBG_UNLOCK_LEVEL to enable Production Debug Mode State. 
                 [br]If a MASK bit is set along with a corresponding bit in SS_DOC_DBG_UNLOCK, Security State will transition to Production Debug Mode from Production Non-Debug state.
                 [br]Otherwise Production Debug Mode can only be entered via LCC.";
         field {sw=rw; hw=r; resetsignal = mci_pwrgood;swwe = axi_mcu_or_mci_soc_config_req__ss_config_unlock_sticky;} MASK[32]=0;
     } SOC_PROD_DEBUG_STATE[2];


    reg {
        name = "Fuse Controller FIPS Zeroization Mask";
         desc = "Masks SOC's cptra_ss_FIPS_ZEROIZATION_PPD_i to send zeroization request to the Fuse Controller. This bit shall be set by MCU ROM and is locked via SS_CONFIG_DONE.
                 [br]If any bit is set to 0, FIPS_ZEROIZATION_PPD_i is masked and no command is sent to the Fuse Controller.
                 [br]If all bits are set to 1 and FPIS_ZEROIZATION_PPD_i is set, FIPS zeriozation command sent to the Fuse Controller.
                 [br]Once SS_CONFIG_DONE is set, this register is read-only.";
         field {sw=rw; hw=r; resetsignal = mci_pwrgood;swwe = axi_mcu_or_mci_soc_config_req__ss_config_unlock_sticky;} MASK[32]=0;
     } FC_FIPS_ZEROZATION;

    // ----------------------------------------
    // ------------ DEBUG/GENERIC -------------
    reg { 
        desc = "Generic input wires connected to SoC interface.";
        field {sw=r;  hw=rw;} wires[32]=32'b0; 
    } GENERIC_INPUT_WIRES[2] @0x400;
    
    reg {
        name = "Generic Output Wires";
        desc = "Generic output wires connected to SoC interface.";
        field {sw=rw; hw=r;} wires[32]=32'b0; 
    } GENERIC_OUTPUT_WIRES[2];
    
    reg { 
        field {sw=rw; hw=na; resetsignal = mci_rst_b;} DATA[32]=32'h0;
    } DEBUG_IN; // i.e. stdin
    reg { 
        field {sw=rw; hw=na; resetsignal = mci_rst_b;} DATA[32]=32'h0;
    } DEBUG_OUT; // i.e. stdout
    
    reg {
        name = "DEBUG INTENT";
        desc = "Strap from SoC in Subsystem configuration that indicates if this boot cycle will be used for debug. In passive mode this register always reflects a value of 0.
                [br]TAP Access [in debug/manuf mode]: RW";
        field strap {sw = r; hw = rw; we; resetsignal = mci_pwrgood;} debug_intent=1'b0;
    } SS_DEBUG_INTENT;


    reg {
        name = "Subsystem Config Done Sticky";
        desc = "Set to indicate that all sticky configuration registers have been populated in MCI.
                Locks configuration registers from further modification.
                [br]Sticky until cold reset once set.
                [br]TAP Access [in debug/manuf mode]: RW";
        field {sw = rw; hw=rw; we; swwe=ss_config_unlock_sticky; swmod=true; resetsignal = mci_pwrgood;} done=1'h0; 
    } SS_CONFIG_DONE_STICKY @0x440;

    reg {
        name = "Subsystem Config Done";
        desc = "Set to indicate that all configuration registers have been populated in MCI.
                Locks configuration registers from further modification.
                [br]Sticky until warm reset once set.
                [br]TAP Access [in debug/manuf mode]: RW";
        field {sw = rw; hw=rw; we; swwe=ss_config_unlock; swmod=true; resetsignal = mci_rst_b;} done=1'h0; 
    } SS_CONFIG_DONE;

    reg {
        name = "Production Debug Unlock PK HASH";
        desc = "Production Debug Unlock PK HASH. Configured by MCU and locked when SS_CONFIG_DONE_STICKY is set.
                Once SS_CONFIG_DONE_STICKY is set value persists until cold reset.";
        field {sw = rw; hw = r; swwe=ss_config_unlock_sticky; resetsignal = mci_pwrgood;} hash[32]=32'h0; 
    } PROD_DEBUG_UNLOCK_PK_HASH_REG[8][12] @0x480;

    // ----------------------------------------
    // ----- DATA_VAULT/SCRATCH/RESERVED ------
    
    // TODO: Add datavalue and lockable scratch registers in the future
    // reg {
    //     name = "STICKY DATA VAULT CTRL";
    //     desc = "Controls for the Sticky Data Vault Entries (cleared on cold reset)
    //             [br]Caliptra Access: RO
    //             [br]MCU Access:      RW
    //             [br]SOC Access:      RO";
    //     field {desc="Lock writes to this entry. Writes will be suppressed when locked.";
    //            sw=rw; swwel=true; hw=r; resetsignal=mci_pwrgood;} lock_entry=0; //TODO Shoud reflect STICKY_DV_NUM_ENTRIES from dv_defines_pkg.sv
    // } STICKY_DATA_VAULT_CTRL[10] @0x800;

    // reg {
    //     name = "STICKY DATA VAULT ENTRY";
    //     desc = "Sticky Data Vault Entry (cleared on cold reset). Lockable.
    //             [br]Caliptra Access: RO
    //             [br]MCU Access:      RW
    //             [br]SOC Access:      RO";
    //     field {desc="DataVault Entry (cleared on cold reset)"; sw=rw; hw=na; swwel=true; resetsignal = mci_pwrgood;} lock_entry=0;
    // } STICKY_DATA_VAULT_ENTRY[10][12];//TODO Shoud reflect STICKY_DV_NUM_ENTRIES and DV_NUM_DWORDS from dv_defines_pkg.sv

    // reg {
    //     name = "DATA VAULT CTRL";
    //     desc = "Controls for the Data Vault Entries (cleared on warm reset)
    //             [br]Caliptra Access: RO
    //             [br]MCU Access:      RW
    //             [br]SOC Access:      RO";
    //     field {desc="Lock writes to this entry. Writes will be suppressed when locked.";
    //            sw=rw; swwel=true; hw=r; resetsignal=mcu_rst_b;} lock_entry=0; // TODO Shoud reflect DV_NUM_ENTRIES and DV_NUM_DWORDS from dv_defines_pkg.sv
    // } DATA_VAULT_CTRL[10];// CAREFUL with the address extensions

    // reg {
    //     name = "DATA VAULT ENTRY";
    //     desc = "Data Vault Entry (cleared on cold reset). Lockable.
    //             [br]Caliptra Access: RO
    //             [br]MCU Access:      RW
    //             [br]SOC Access:      RO";
    //     field {desc="DataVault Entry (cleared on cold reset)"; sw=rw; hw=na; swwel=true; resetsignal = mci_pwrgood;} lock_entry=0;
    // } DATA_VAULT_ENTRY[10][12];// TODO Shoud reflect DV_NUM_ENTRIES and DV_NUM_DWORDS from dv_defines_pkg.sv

    // reg {
    //     name = "STICKY LOCKABLE SCRATCH REG CTRL";
    //     desc = "Sticky Scratch Register Controls (cleared on cold reset)
    //             [br]Caliptra Access: RO
    //             [br]MCU Access:      RW
    //             [br]SOC Access:      RO";
    //     field {desc="Lock writes to the Scratch registers. Writes will be suppressed when locked.";
    //            sw=rw; swwel=true; hw=r; resetsignal=mci_pwrgood;} lock_entry=0;
    // } STICKY_LOCKABLE_SCRATCH_REG_CTRL[8]; // TODO should reflect STICKY_LOCKQ_SCRATCH_NUM_ENTRIES


    //reg {
    //    name = "STICKY LOCKABLE SCRATCH REG";
    //    desc = "Sticky Scratch Register Entries (cleared on cold reset)
    //            [br]Caliptra Access: RO
    //            [br]MCU Access:      RW
    //            [br]SOC Access:      RO";
    //    field {sw=rw; swwel=true; hw=na; resetsignal=mci_pwrgood;} data[32]=0;
    //} STICKY_LOCKABLE_SCRATCH_REG[8]; // TODO should reflect STICKY_LOCKQ_SCRATCH_NUM_ENTRIES

    //reg {
    //    name = "LOCKABLE SCRATCH REG CTRL";
    //    desc = "Scratch Register Controls (cleared on warm reset)
    //            [br]Caliptra Access: RO
    //            [br]MCU Access:      RW
    //            [br]SOC Access:      RO";
    //    field {desc="Lock writes to the Scratch registers. Writes will be suppressed when locked.";
    //           sw=rw; swwel=true; hw=r; resetsignal=mcu_rst_b;} lock_entry=0;
    //} LOCKABLE_SCRATCH_REG_CTRL[10]; // TODO Shoud reflect LOCK_SCRATCH_NUM_ENTRIES from dv_defines_pkg.sv & CAREFUL with the address extensions

    //reg {
    //    name = "LOCKABLE SCRATCH REG";
    //    desc = "Scratch Register Entry (cleared on cold reset)
    //            [br]Caliptra Access: RO
    //            [br]MCU Access:      RW
    //            [br]SOC Access:      RO";
    //    field {sw=rw; swwel=true; hw=na; resetsignal=mci_pwrgood;} data[32]=0;
    //} LOCKABLE_SCRATCH_REG[10]; // TODO Shoud reflect LOCK_SCRATCH_NUM_ENTRIES from dv_defines_pkg.sv

    // reg {
    //     name = "NON STICKY GENERIC SCRATCH REG";
    //     desc = "
    //             [br]Caliptra Access: RO
    //             [br]MCU Access:      RW
    //             [br]SOC Access:      RO";
    //     field {sw=rw; hw=na; resetsignal=mci_rst_b;} data[32]=0; 
    // } NON_STICKY_GENERIC_SCRATCH_REG[8]; // TODO Shoud reflect NONSTICKY_SCRATCH_NUM_ENTRIES from dv_defines_pkg.sv & CAREFUL with the address extensions

////////////////////////////////////////////////////////////////
// Interrupts
/* -----------------------
 * Register File definitive definition
 * ----------------------- */

// Notifications are non-error events that occur during normal operation of the module.
// E.g. a completion of a job may produce a notification.
// Error and notification events are separated into separate status/trigger registers
// to allow effective priority allocation by software
regfile intr_block_t {


    /* -----------------------
     * Default properties for Register File
     * ----------------------- */

    name = "Interrupt Register Block";
    desc = "Set of registers to implement interrupt functionality
            for soc interface.
            All registers have the following access privileges:
            [br]MCU Access: RW
            [br]SOC Access:      RO";

    default regwidth = 32; // reg property
    default accesswidth = 32; // reg property
    default hw = na; // field property
    default swwe = axi_mcu_or_mci_soc_config_req; // MCU should be the only entity that can control the interrupt registers


    /* -----------------------
     * Register definitive definitions
     * ----------------------- */

    /* ---- Global Interrupt Enable ---- */
    reg global_intr_en_t {
        name = "Per-Type Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event type that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Global enablement (for interrupts of the event types defined for this module)
        field {desc = "Global enable bit for all events of type 'Error'";       } error_en = 1'b0;
        field {desc = "Global enable bit for all events of type 'Notification'";} notif_en = 1'b0;
    };

    /* ---- Error Interrupt Enable ---- */
    reg error0_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Specific enables for the events defined in this
        // event type in the instantiating peripheral.
        field {desc = "Enable bit for Collision between AXI and DMI port in MCU SRAM.";                            } error_mcu_sram_dmi_axi_collision_en = 1'b0;
        field {desc = "Enable bit for Internal Errors";                                                            } error_internal_en = 1'b0;
        field {desc = "Enable bit for Mailbox ECC Double-bit Error (uncorrectable)";                               } error_mbox0_ecc_unc_en = 1'b0;
        field {desc = "Enable bit for Mailbox ECC Double-bit Error (uncorrectable)";                               } error_mbox1_ecc_unc_en = 1'b0;
        field {desc = "Enable bit for WDT Timer1 timeout";                                                         } error_wdt_timer1_timeout_en = 1'b0;
        field {desc = "Enable bit for WDT Timer2 timeout, applicable if timer2 is enabled as an independent timer";} error_wdt_timer2_timeout_en = 1'b0;
    };
    reg error1_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;


        field {desc = "Enable bit MCI Aggregate Error fatal bit 31";                                   } error_agg_error_fatal31_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 30";                                   } error_agg_error_fatal30_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 29";                                   } error_agg_error_fatal29_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 28";                                   } error_agg_error_fatal28_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 27";                                   } error_agg_error_fatal27_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 26";                                   } error_agg_error_fatal26_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 25";                                   } error_agg_error_fatal25_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 24";                                   } error_agg_error_fatal24_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 23";                                   } error_agg_error_fatal23_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 22";                                   } error_agg_error_fatal22_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 21";                                   } error_agg_error_fatal21_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 20";                                   } error_agg_error_fatal20_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 19";                                   } error_agg_error_fatal19_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 18";                                   } error_agg_error_fatal18_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 17";                                   } error_agg_error_fatal17_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 16";                                   } error_agg_error_fatal16_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 15";                                   } error_agg_error_fatal15_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 14";                                   } error_agg_error_fatal14_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 13";                                   } error_agg_error_fatal13_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 12";                                   } error_agg_error_fatal12_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 11";                                   } error_agg_error_fatal11_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 10";                                   } error_agg_error_fatal10_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 9";                                   } error_agg_error_fatal9_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 8";                                   } error_agg_error_fatal8_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 7";                                   } error_agg_error_fatal7_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 6";                                   } error_agg_error_fatal6_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 5";                                   } error_agg_error_fatal5_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 4";                                   } error_agg_error_fatal4_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 3";                                   } error_agg_error_fatal3_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 2";                                   } error_agg_error_fatal2_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 1";                                   } error_agg_error_fatal1_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error fatal bit 0";                                   } error_agg_error_fatal0_en = 1'b0;
    };

    /* ---- Notification Interrupt Enable ---- */
    reg notif0_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;

        // Specific enables for the events defined in this
        // event type in the instantiating peripheral.
        field {desc = "Enable bit for MCUS SRAM ECC Single-bit Error (corretable)";     } notif_mcu_sram_ecc_cor_en = 1'b0;
        field {desc = "Enable bit for Caliptra requests MCU to reset itself";           } notif_cptra_mcu_reset_req_en = 1'b0;
        field {desc = "Enable bit for Generic Input Wires Toggle";                      } notif_gen_in_toggle_en = 1'b0;
        field {desc = "Enable bit for MBOX0 Target done and status available";          } notif_mbox0_target_done_en = 1'b0;
        field {desc = "Enable bit for MBOX1 Target done and status available";          } notif_mbox1_target_done_en = 1'b0;
        field {desc = "Enable bit for MBOX0 Command Available";                         } notif_mbox0_cmd_avail_en = 1'b0;
        field {desc = "Enable bit for MBOX1 Command Available";                         } notif_mbox1_cmd_avail_en = 1'b0;
        field {desc = "Enable bit for Caliptra MBOX Command Available";                 } notif_cptra_mbox_cmd_avail_en = 1'b0;
        field {desc = "Enable bit for Mailbox ECC Single-bit Error (correctable)";      } notif_mbox0_ecc_cor_en = 1'b0;
        field {desc = "Enable bit for Mailbox ECC Single-bit Error (correctable)";      } notif_mbox1_ecc_cor_en = 1'b0;
        field {desc = "Enable bit for Security State, Debug Locked transition";         } notif_debug_locked_en = 1'b0;
        field {desc = "Enable bit for Scan mode asserted";                              } notif_scan_mode_en = 1'b0;
        field {desc = "Enable bit for SoC requested the mailbox while mcu has lock";          } notif_mbox0_soc_req_lock_en = 1'b0;
        field {desc = "Enable bit for SoC requested the mailbox while mcu has lock";          } notif_mbox1_soc_req_lock_en = 1'b0;
    };
    reg notif1_intr_en_t {
        name = "Per-Event Interrupt Enable Register";
        desc = "Dedicated register with one bit for each event that may produce an interrupt.";

        default hw = na;
        default sw = rw;


        field {desc = "Enable bit MCI Aggregate Error non fatal bit 31";                                   } notif_agg_error_non_fatal31_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 30";                                   } notif_agg_error_non_fatal30_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 29";                                   } notif_agg_error_non_fatal29_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 28";                                   } notif_agg_error_non_fatal28_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 27";                                   } notif_agg_error_non_fatal27_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 26";                                   } notif_agg_error_non_fatal26_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 25";                                   } notif_agg_error_non_fatal25_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 24";                                   } notif_agg_error_non_fatal24_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 23";                                   } notif_agg_error_non_fatal23_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 22";                                   } notif_agg_error_non_fatal22_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 21";                                   } notif_agg_error_non_fatal21_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 20";                                   } notif_agg_error_non_fatal20_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 19";                                   } notif_agg_error_non_fatal19_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 18";                                   } notif_agg_error_non_fatal18_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 17";                                   } notif_agg_error_non_fatal17_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 16";                                   } notif_agg_error_non_fatal16_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 15";                                   } notif_agg_error_non_fatal15_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 14";                                   } notif_agg_error_non_fatal14_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 13";                                   } notif_agg_error_non_fatal13_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 12";                                   } notif_agg_error_non_fatal12_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 11";                                   } notif_agg_error_non_fatal11_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 10";                                   } notif_agg_error_non_fatal10_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 9";                                   } notif_agg_error_non_fatal9_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 8";                                   } notif_agg_error_non_fatal8_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 7";                                   } notif_agg_error_non_fatal7_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 6";                                   } notif_agg_error_non_fatal6_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 5";                                   } notif_agg_error_non_fatal5_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 4";                                   } notif_agg_error_non_fatal4_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 3";                                   } notif_agg_error_non_fatal3_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 2";                                   } notif_agg_error_non_fatal2_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 1";                                   } notif_agg_error_non_fatal1_en = 1'b0;
        field {desc = "Enable bit MCI Aggregate Error non fatal bit 0";                                   } notif_agg_error_non_fatal0_en = 1'b0;
    };

    /* ---- Error Interrupt Status ---- */
    reg error0_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "Collision between AXI and DMI port in MCU SRAM.";                 } error_mcu_sram_dmi_axi_collision_sts = 1'b0;
        field {desc = "Internal Errors status bit";                                      } error_internal_sts = 1'b0;
        field {desc = "Mailbox ECC Double-bit Error (uncorrectable) status bit";         } error_mbox0_ecc_unc_sts = 1'b0;
        field {desc = "Mailbox ECC Double-bit Error (uncorrectable) status bit";         } error_mbox1_ecc_unc_sts = 1'b0;
        field {hw = rw; desc = "WDT Timer1 timeout status bit";                                   } error_wdt_timer1_timeout_sts = 1'b0;
        field {hw = rw; desc = "WDT Timer2 timeout status bit";                                   } error_wdt_timer2_timeout_sts = 1'b0;
    };
    reg error1_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "MCI Aggregate Error fatal bit 31";                                   } error_agg_error_fatal31_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 30";                                   } error_agg_error_fatal30_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 29";                                   } error_agg_error_fatal29_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 28";                                   } error_agg_error_fatal28_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 27";                                   } error_agg_error_fatal27_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 26";                                   } error_agg_error_fatal26_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 25";                                   } error_agg_error_fatal25_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 24";                                   } error_agg_error_fatal24_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 23";                                   } error_agg_error_fatal23_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 22";                                   } error_agg_error_fatal22_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 21";                                   } error_agg_error_fatal21_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 20";                                   } error_agg_error_fatal20_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 19";                                   } error_agg_error_fatal19_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 18";                                   } error_agg_error_fatal18_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 17";                                   } error_agg_error_fatal17_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 16";                                   } error_agg_error_fatal16_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 15";                                   } error_agg_error_fatal15_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 14";                                   } error_agg_error_fatal14_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 13";                                   } error_agg_error_fatal13_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 12";                                   } error_agg_error_fatal12_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 11";                                   } error_agg_error_fatal11_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 10";                                   } error_agg_error_fatal10_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 9";                                    } error_agg_error_fatal9_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 8";                                    } error_agg_error_fatal8_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 7";                                    } error_agg_error_fatal7_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 6";                                    } error_agg_error_fatal6_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 5";                                    } error_agg_error_fatal5_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 4";                                    } error_agg_error_fatal4_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 3";                                    } error_agg_error_fatal3_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 2";                                    } error_agg_error_fatal2_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 1";                                    } error_agg_error_fatal1_sts = 1'b0;
        field {desc = "MCI Aggregate Error fatal bit 0";                                    } error_agg_error_fatal0_sts = 1'b0;
    };

    /* ---- Notification Interrupt Status ---- */
    reg notif0_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "MCU SRAM ECC Single-bit Error (correctable) status bit";} notif_mcu_sram_ecc_cor_sts = 1'b0;
        field {desc = "Caliptra requests MCU to reset itself status bit";      } notif_cptra_mcu_reset_req_sts = 1'b0;
        field {desc = "Generic Input Wires Toggle status bit";                 } notif_gen_in_toggle_sts = 1'b0;
        field {desc = "MBOX0 Target done and status available bit";            } notif_mbox0_target_done_sts = 1'b0;
        field {desc = "MBOX1 Target done and status available bit";            } notif_mbox1_target_done_sts = 1'b0;
        field {desc = "MBOX0 Command Available status bit";                    } notif_mbox0_cmd_avail_sts = 1'b0;
        field {desc = "MBOX1 Command Available status bit";                    } notif_mbox1_cmd_avail_sts = 1'b0;
        field {desc = "Caliptra MBOX Command Available status bit";            } notif_cptra_mbox_cmd_avail_sts = 1'b0;
        field {desc = "Mailbox ECC Single-bit Error (correctable) status bit"; } notif_mbox0_ecc_cor_sts = 1'b0;
        field {desc = "Mailbox ECC Single-bit Error (correctable) status bit"; } notif_mbox1_ecc_cor_sts = 1'b0;
        field {desc = "Security State, Debug Locked transition status bit";    } notif_debug_locked_sts = 1'b0;
        field {desc = "Scan mode asserted status bit";                         } notif_scan_mode_sts = 1'b0;
        field {desc = "SoC requested the mailbox while mcu has lock status bit";     } notif_mbox0_soc_req_lock_sts = 1'b0;
        field {desc = "SoC requested the mailbox while mcu has lock status bit";     } notif_mbox1_soc_req_lock_sts = 1'b0;
    };
    reg notif1_intr_t {
        name = "Interrupt Status Register type definition";
        desc = "Single bit indicating occurrence of each interrupt event.
                Sticky, level assertion, write-1-to-clear.";

        default precedence = hw;
        default hw = w;
        default hwset = true;
        default sw = rw;
        default woclr = true;
        default level intr;

        field {desc = "MCI Aggregate Error non fatal bit 31";                                   } notif_agg_error_non_fatal31_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 30";                                   } notif_agg_error_non_fatal30_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 29";                                   } notif_agg_error_non_fatal29_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 28";                                   } notif_agg_error_non_fatal28_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 27";                                   } notif_agg_error_non_fatal27_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 26";                                   } notif_agg_error_non_fatal26_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 25";                                   } notif_agg_error_non_fatal25_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 24";                                   } notif_agg_error_non_fatal24_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 23";                                   } notif_agg_error_non_fatal23_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 22";                                   } notif_agg_error_non_fatal22_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 21";                                   } notif_agg_error_non_fatal21_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 20";                                   } notif_agg_error_non_fatal20_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 19";                                   } notif_agg_error_non_fatal19_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 18";                                   } notif_agg_error_non_fatal18_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 17";                                   } notif_agg_error_non_fatal17_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 16";                                   } notif_agg_error_non_fatal16_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 15";                                   } notif_agg_error_non_fatal15_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 14";                                   } notif_agg_error_non_fatal14_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 13";                                   } notif_agg_error_non_fatal13_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 12";                                   } notif_agg_error_non_fatal12_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 11";                                   } notif_agg_error_non_fatal11_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 10";                                   } notif_agg_error_non_fatal10_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 9";                                   } notif_agg_error_non_fatal9_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 8";                                   } notif_agg_error_non_fatal8_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 7";                                   } notif_agg_error_non_fatal7_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 6";                                   } notif_agg_error_non_fatal6_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 5";                                   } notif_agg_error_non_fatal5_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 4";                                   } notif_agg_error_non_fatal4_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 3";                                   } notif_agg_error_non_fatal3_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 2";                                   } notif_agg_error_non_fatal2_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 1";                                   } notif_agg_error_non_fatal1_sts = 1'b0;
        field {desc = "MCI Aggregate Error non fatal bit 0";                                   } notif_agg_error_non_fatal0_sts = 1'b0;
    };

    /* ---- Aggregated Interrupt Status ---- */
    reg global_intr_t {
        name = "Interrupt Status Aggregation Register type definition";
        desc = "Single bit indicating occurrence of any interrupt event
                of a given type. E.g. Notifications and Errors may drive
                to two separate interrupt registers. There may be
                multiple sources of Notifications or Errors that are
                aggregated into a single interrupt pin for that
                respective type. That pin feeds through this register
                in order to apply a global enablement of that interrupt
                event type.
                Nonsticky assertion.";

        default hw = w;
        default sw = r;
        default nonsticky intr;

        field {desc = "Interrupt Event Aggregation status bit"; swwel = false;} agg_sts0 = 1'b0;
        field {desc = "Interrupt Event Aggregation status bit"; swwel = false;} agg_sts1 = 1'b0;
    };

    /* ---- Error Interrupt Trigger ---- */
    reg error0_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the trigger bit
                will pulse for 1 cycle then clear to 0. The pulse on the
                trigger register bit results in the corresponding interrupt
                status bit being set to 1.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;

        // Instantiate triggers bit-by-bit.
        field {desc = "Collision between AXI and DMI port in MCU SRAM trigger bit";     } error_mcu_sram_dmi_axi_collision_trig = 1'b0;
        field {desc = "Internal Errors trigger bit";                                    } error_internal_trig = 1'b0;
        field {desc = "Mailbox ECC Double-bit Error (uncorrectable) trigger bit";       } error_mbox0_ecc_unc_trig = 1'b0;
        field {desc = "Mailbox ECC Double-bit Error (uncorrectable) trigger bit";       } error_mbox1_ecc_unc_trig = 1'b0;
        field {desc = "WDT Timer1 timeout trigger bit";                                 } error_wdt_timer1_timeout_trig = 1'b0;
        field {desc = "WDT Timer2 timeout trigger bit";                                 } error_wdt_timer2_timeout_trig = 1'b0;
    };
    reg error1_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the trigger bit
                will pulse for 1 cycle then clear to 0. The pulse on the
                trigger register bit results in the corresponding interrupt
                status bit being set to 1.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;


        field {desc = "Trigger bit MCI Aggregate Error fatal bit 31";                                   } error_agg_error_fatal31_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 30";                                   } error_agg_error_fatal30_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 29";                                   } error_agg_error_fatal29_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 28";                                   } error_agg_error_fatal28_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 27";                                   } error_agg_error_fatal27_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 26";                                   } error_agg_error_fatal26_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 25";                                   } error_agg_error_fatal25_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 24";                                   } error_agg_error_fatal24_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 23";                                   } error_agg_error_fatal23_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 22";                                   } error_agg_error_fatal22_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 21";                                   } error_agg_error_fatal21_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 20";                                   } error_agg_error_fatal20_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 19";                                   } error_agg_error_fatal19_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 18";                                   } error_agg_error_fatal18_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 17";                                   } error_agg_error_fatal17_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 16";                                   } error_agg_error_fatal16_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 15";                                   } error_agg_error_fatal15_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 14";                                   } error_agg_error_fatal14_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 13";                                   } error_agg_error_fatal13_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 12";                                   } error_agg_error_fatal12_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 11";                                   } error_agg_error_fatal11_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 10";                                   } error_agg_error_fatal10_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 9";                                    } error_agg_error_fatal9_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 8";                                    } error_agg_error_fatal8_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 7";                                    } error_agg_error_fatal7_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 6";                                    } error_agg_error_fatal6_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 5";                                    } error_agg_error_fatal5_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 4";                                    } error_agg_error_fatal4_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 3";                                    } error_agg_error_fatal3_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 2";                                    } error_agg_error_fatal2_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 1";                                    } error_agg_error_fatal1_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error fatal bit 0";                                    } error_agg_error_fatal0_trig = 1'b0;
    };

    /* ---- Notification Interrupt Trigger ---- */
    reg notif0_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the trigger bit
                will pulse for 1 cycle then clear to 0. The pulse on the
                trigger register bit results in the corresponding interrupt
                status bit being set to 1.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;

        // Instantiate triggers bit-by-bit.
        field {desc = "MCU SRAM ECC Single-bit Error (correctable) trigger bit";} notif_mcu_sram_ecc_cor_trig = 1'b0;
        field {desc = "Caliptra requests MCU to reset itself trigger bit";      } notif_cptra_mcu_reset_req_trig = 1'b0;
        field {desc = "Generic Input Wires Toggle trigger bit";                 } notif_gen_in_toggle_trig = 1'b0;
        field {desc = "MBOX0 Target done and status available trigger bit";     } notif_mbox0_target_done_trig = 1'b0;
        field {desc = "MBOX1 Target done and status available trigger bit";     } notif_mbox1_target_done_trig = 1'b0;
        field {desc = "MBOX0 Command Available trigger bit";                    } notif_mbox0_cmd_avail_trig = 1'b0;
        field {desc = "MBOX1 Command Available trigger bit";                    } notif_mbox1_cmd_avail_trig = 1'b0;
        field {desc = "Caliptra MBOX Command Available trigger bit";            } notif_cptra_mbox_cmd_avail_trig = 1'b0;
        field {desc = "Mailbox ECC Single-bit Error (correctable) trigger bit"; } notif_mbox0_ecc_cor_trig = 1'b0;
        field {desc = "Mailbox ECC Single-bit Error (correctable) trigger bit"; } notif_mbox1_ecc_cor_trig = 1'b0;
        field {desc = "Security State, Debug Locked transition trigger bit";    } notif_debug_locked_trig = 1'b0;
        field {desc = "Scan mode asserted trigger bit";                         } notif_scan_mode_trig = 1'b0;
        field {desc = "SoC requested the mailbox while mcu has lock trigger bit";     } notif_mbox0_soc_req_lock_trig = 1'b0;
        field {desc = "SoC requested the mailbox while mcu has lock trigger bit";     } notif_mbox1_soc_req_lock_trig = 1'b0;
    };

    reg notif1_intr_trig_t {
        name = "Interrupt Trigger Register type definition";
        desc = "Single bit for each interrupt event allows SW to manually
                trigger occurrence of that event. Upon SW write, the trigger bit
                will pulse for 1 cycle then clear to 0. The pulse on the
                trigger register bit results in the corresponding interrupt
                status bit being set to 1.";

        default hw = na;
        default sw = rw;
        default woset = true;
        default singlepulse = true;


        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 31";                                   } notif_agg_error_non_fatal31_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 30";                                   } notif_agg_error_non_fatal30_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 29";                                   } notif_agg_error_non_fatal29_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 28";                                   } notif_agg_error_non_fatal28_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 27";                                   } notif_agg_error_non_fatal27_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 26";                                   } notif_agg_error_non_fatal26_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 25";                                   } notif_agg_error_non_fatal25_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 24";                                   } notif_agg_error_non_fatal24_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 23";                                   } notif_agg_error_non_fatal23_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 22";                                   } notif_agg_error_non_fatal22_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 21";                                   } notif_agg_error_non_fatal21_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 20";                                   } notif_agg_error_non_fatal20_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 19";                                   } notif_agg_error_non_fatal19_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 18";                                   } notif_agg_error_non_fatal18_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 17";                                   } notif_agg_error_non_fatal17_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 16";                                   } notif_agg_error_non_fatal16_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 15";                                   } notif_agg_error_non_fatal15_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 14";                                   } notif_agg_error_non_fatal14_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 13";                                   } notif_agg_error_non_fatal13_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 12";                                   } notif_agg_error_non_fatal12_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 11";                                   } notif_agg_error_non_fatal11_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 10";                                   } notif_agg_error_non_fatal10_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 9";                                    } notif_agg_error_non_fatal9_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 8";                                    } notif_agg_error_non_fatal8_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 7";                                    } notif_agg_error_non_fatal7_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 6";                                    } notif_agg_error_non_fatal6_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 5";                                    } notif_agg_error_non_fatal5_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 4";                                    } notif_agg_error_non_fatal4_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 3";                                    } notif_agg_error_non_fatal3_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 2";                                    } notif_agg_error_non_fatal2_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 1";                                    } notif_agg_error_non_fatal1_trig = 1'b0;
        field {desc = "Trigger bit MCI Aggregate Error non fatal bit 0";                                    } notif_agg_error_non_fatal0_trig = 1'b0;
    };
    /* ---- Interrupt Statistics Counter Incrementor ---- */
    reg intr_count_incr_t {
        name = "Interrupt Event Count Incrementor";
        desc = "Trigger the event counter to increment based on observing
                the rising edge of an interrupt event input from the
                Hardware. The same input signal that causes an interrupt
                event to be set (sticky) also causes this signal to pulse
                for 1 clock cycle, resulting in the event counter
                incrementing by 1 for every interrupt event.
                This is implemented as a down-counter (1-bit) that will
                decrement immediately on being set - resulting in a pulse";

        default hw = w;
        default sw = r; // Has to have some access.... ideally SW wouldn't even see this
        default hwset = true;
        default decrvalue = 1;
        default counter;

        field {desc = "Pulse mirrors interrupt event occurrence"; swwel = false;} pulse = 1'b0;
    };

    /* ---- Interrupt Statistics Counter ---- */
    reg intr_count_t {
        name = "Interrupt Event Counter";
        desc = "Provides statistics about the number of events that have
                occurred.
                Will not overflow ('incrsaturate').";

        default sw = rw;
        default hw = na;
        default incrvalue = 1;
        default incrsaturate = true;
        default counter;

        field {desc = "Count field";} cnt[32] = 32'h0;
    };


    /* ------------------------------------------------- Registers ------------------------------------------------- */
    // First 9 registers are static and always defined                                                               //
    global_intr_en_t  global_intr_en_r;      /* 1-bit per event type */                                              //
    error0_intr_en_t   error0_intr_en_r;       /* 1-bit per error */                                                   //
    error1_intr_en_t   error1_intr_en_r;       /* 1-bit per error */                                                   //
    notif0_intr_en_t   notif0_intr_en_r;       /* 1-bit per notification */                                            //
    notif1_intr_en_t   notif1_intr_en_r;       /* 1-bit per notification */                                            //
    global_intr_t     error_global_intr_r;   /* 1-bit aggregating all error interrupts with global enable */         //
    global_intr_t     notif_global_intr_r;   /* 1-bit aggregating all notification interrupts with global enable */  //
    error0_intr_t      error0_internal_intr_r; /* Error pending, SW write 1 to clear */                                //
    error1_intr_t      error1_internal_intr_r; /* Error pending, SW write 1 to clear */                                //
    notif0_intr_t      notif0_internal_intr_r; /* Notification pending, SW write 1 to clear */                         //
    notif1_intr_t      notif1_internal_intr_r; /* Notification pending, SW write 1 to clear */                         //
    error0_intr_trig_t error0_intr_trig_r;     /* SW sets error bit for interrupt testing */                           //
    error1_intr_trig_t error1_intr_trig_r;     /* SW sets error bit for interrupt testing */                           //
    notif0_intr_trig_t notif0_intr_trig_r;     /* SW sets notification bit for interrupt testing */                    //
    notif1_intr_trig_t notif1_intr_trig_r;     /* SW sets notification bit for interrupt testing */                    //
                                                                                                                     //
    // Align this set of registers; number of counters is based on peripheral event requirements                     //
    intr_count_t      error_internal_intr_count_r @0x100;  /* Per error */                                           //
    intr_count_t      error_mbox0_ecc_unc_intr_count_r;     /* Per error */                                           //
    intr_count_t      error_mbox1_ecc_unc_intr_count_r;     /* Per error */                                           //
    intr_count_t      error_mcu_sram_dmi_axi_collision_intr_count_r;     /* Per error */                                           //
    intr_count_t      error_wdt_timer1_timeout_intr_count_r;  /* Per error */                                         //
    intr_count_t      error_wdt_timer2_timeout_intr_count_r; /* Per error */                                         //
    intr_count_t      error_agg_error_fatal0_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal1_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal2_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal3_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal4_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal5_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal6_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal7_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal8_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal9_intr_count_r;    /* Per error  */                              //
    intr_count_t      error_agg_error_fatal10_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal11_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal12_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal13_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal14_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal15_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal16_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal17_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal18_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal19_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal20_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal21_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal22_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal23_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal24_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal25_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal26_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal27_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal28_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal29_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal30_intr_count_r;   /* Per error  */                              //
    intr_count_t      error_agg_error_fatal31_intr_count_r;   /* Per error  */                              //
    intr_count_t      notif_mcu_sram_ecc_cor_intr_count_r @0x200;     /* Per notification */                                    //
    intr_count_t      notif_cptra_mcu_reset_req_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_gen_in_toggle_intr_count_r;    /* Per notification */                                    //
    intr_count_t      notif_agg_error_non_fatal0_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal1_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal2_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal3_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal4_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal5_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal6_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal7_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal8_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal9_intr_count_r;    /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal10_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal11_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal12_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal13_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal14_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal15_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal16_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal17_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal18_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal19_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal20_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal21_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal22_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal23_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal24_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal25_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal26_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal27_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal28_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal29_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal30_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_agg_error_non_fatal31_intr_count_r;   /* Per notification  */                              //
    intr_count_t      notif_mbox0_target_done_intr_count_r; /* Per notification */                                    //
    intr_count_t      notif_mbox1_target_done_intr_count_r; /* Per notification */                                    //
    intr_count_t      notif_mbox0_cmd_avail_intr_count_r; /* Per notification */                                    //
    intr_count_t      notif_mbox1_cmd_avail_intr_count_r; /* Per notification */                                    //
    intr_count_t      notif_cptra_mbox_cmd_avail_intr_count_r; /* Per notification */                                    //
    intr_count_t      notif_mbox0_ecc_cor_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_mbox1_ecc_cor_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_debug_locked_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_scan_mode_intr_count_r;        /* Per notification */                                    //
    intr_count_t      notif_mbox0_soc_req_lock_intr_count_r;     /* Per notification */                                    //
    intr_count_t      notif_mbox1_soc_req_lock_intr_count_r;     /* Per notification */                                    //
                                                                                                                     //
    // These registers should be treated by SW as reserved, and ignored.                                             //
    // Offset at 0x200 gives enough space for 32 Errors and 32 Notifications                                         //
    // to be implemented (requiring 2*32 32-bit registers starting at                                                //
    // offset 0x100), and still allowing the entire regfile to fit                                                   //
    // inside a 1024-byte space.                                                                                     //
    intr_count_incr_t error_internal_intr_count_incr_r @0x300; /* Per error count incrementor pulse */               //
    intr_count_incr_t error_mbox0_ecc_unc_intr_count_incr_r;    /* Per error count incrementor pulse */               //
    intr_count_incr_t error_mbox1_ecc_unc_intr_count_incr_r;    /* Per error count incrementor pulse */               //
    intr_count_incr_t error_wdt_timer1_timeout_intr_count_incr_r;  /* Per error count incrementor pulse */            //
    intr_count_incr_t error_wdt_timer2_timeout_intr_count_incr_r; /* Per error count incrementor pulse */            //
    intr_count_incr_t error_mcu_sram_dmi_axi_collision_intr_count_incr_r;     /* Per error count incrementor pulse */                                           //
    intr_count_incr_t error_agg_error_fatal0_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal1_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal2_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal3_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal4_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal5_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal6_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal7_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal8_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal9_intr_count_incr_r;    /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal10_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal11_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal12_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal13_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal14_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal15_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal16_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal17_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal18_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal19_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal20_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal21_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal22_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal23_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal24_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal25_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal26_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal27_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal28_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal29_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal30_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t error_agg_error_fatal31_intr_count_incr_r;   /* Per error count incrementor pulse */                              //
    intr_count_incr_t notif_mcu_sram_ecc_cor_intr_count_incr_r;                    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_cptra_mcu_reset_req_intr_count_incr_r;                 /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_gen_in_toggle_intr_count_incr_r;   /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_agg_error_non_fatal0_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal1_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal2_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal3_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal4_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal5_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal6_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal7_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal8_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal9_intr_count_incr_r;    /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal10_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal11_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal12_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal13_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal14_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal15_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal16_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal17_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal18_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal19_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal20_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal21_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal22_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal23_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal24_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal25_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal26_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal27_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal28_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal29_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal30_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_agg_error_non_fatal31_intr_count_incr_r;   /* Per notification count incrementor pulse  */                              //
    intr_count_incr_t notif_mbox0_target_done_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox1_target_done_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox0_cmd_avail_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox1_cmd_avail_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_cptra_mbox_cmd_avail_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox0_ecc_cor_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox1_ecc_cor_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_debug_locked_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_scan_mode_intr_count_incr_r;       /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox0_soc_req_lock_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    intr_count_incr_t notif_mbox1_soc_req_lock_intr_count_incr_r;    /* Per notification count incrementor pulse */        //
    /* ------------------------------------------------------------------------------------------------------------- */

    /* ---- Reset assignment for Error Events ---- */
    error0_internal_intr_r.error_internal_sts     -> resetsignal = mci_pwrgood;
    error0_internal_intr_r.error_mbox0_ecc_unc_sts -> resetsignal = mci_pwrgood;
    error0_internal_intr_r.error_mbox1_ecc_unc_sts -> resetsignal = mci_pwrgood;
    error0_internal_intr_r.error_wdt_timer1_timeout_sts -> resetsignal = mci_pwrgood;
    error0_internal_intr_r.error_wdt_timer2_timeout_sts -> resetsignal = mci_pwrgood;
    error0_internal_intr_r.error_mcu_sram_dmi_axi_collision_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal0_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal1_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal2_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal3_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal4_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal5_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal6_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal7_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal8_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal9_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal10_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal11_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal12_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal13_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal14_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal15_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal16_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal17_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal18_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal19_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal20_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal21_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal22_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal23_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal24_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal25_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal26_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal27_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal28_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal29_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal30_sts -> resetsignal = mci_pwrgood;
    error1_internal_intr_r.error_agg_error_fatal31_sts -> resetsignal = mci_pwrgood;
    error_internal_intr_count_r.cnt          -> resetsignal = mci_pwrgood;
    error_mbox0_ecc_unc_intr_count_r.cnt      -> resetsignal = mci_pwrgood;
    error_mbox1_ecc_unc_intr_count_r.cnt      -> resetsignal = mci_pwrgood;
    error_wdt_timer1_timeout_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_wdt_timer2_timeout_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_mcu_sram_dmi_axi_collision_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal0_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal1_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal2_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal3_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal4_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal5_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal6_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal7_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal8_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal9_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal10_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal11_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal12_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal13_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal14_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal15_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal16_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal17_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal18_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal19_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal20_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal21_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal22_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal23_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal24_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal25_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal26_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal27_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal28_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal29_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal30_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    error_agg_error_fatal31_intr_count_r.cnt -> resetsignal = mci_pwrgood;
    // TODO: Use this same reset for the error incrementor pulse too?

    /* ---- Interrupt Event Dynamic Assignments ---- */
    error0_internal_intr_r.error_internal_sts     -> enable = error0_intr_en_r.error_internal_en;
    error0_internal_intr_r.error_mbox0_ecc_unc_sts -> enable = error0_intr_en_r.error_mbox0_ecc_unc_en;
    error0_internal_intr_r.error_mbox1_ecc_unc_sts -> enable = error0_intr_en_r.error_mbox1_ecc_unc_en;
    error0_internal_intr_r.error_wdt_timer1_timeout_sts -> enable = error0_intr_en_r.error_wdt_timer1_timeout_en;
    error0_internal_intr_r.error_wdt_timer2_timeout_sts -> enable = error0_intr_en_r.error_wdt_timer2_timeout_en;
    error0_internal_intr_r.error_mcu_sram_dmi_axi_collision_sts -> enable = error0_intr_en_r.error_mcu_sram_dmi_axi_collision_en;
    error1_internal_intr_r.error_agg_error_fatal0_sts -> enable = error1_intr_en_r.error_agg_error_fatal0_en;
    error1_internal_intr_r.error_agg_error_fatal1_sts -> enable = error1_intr_en_r.error_agg_error_fatal1_en;
    error1_internal_intr_r.error_agg_error_fatal2_sts -> enable = error1_intr_en_r.error_agg_error_fatal2_en;
    error1_internal_intr_r.error_agg_error_fatal3_sts -> enable = error1_intr_en_r.error_agg_error_fatal3_en;
    error1_internal_intr_r.error_agg_error_fatal4_sts -> enable = error1_intr_en_r.error_agg_error_fatal4_en;
    error1_internal_intr_r.error_agg_error_fatal5_sts -> enable = error1_intr_en_r.error_agg_error_fatal5_en;
    error1_internal_intr_r.error_agg_error_fatal6_sts -> enable = error1_intr_en_r.error_agg_error_fatal6_en;
    error1_internal_intr_r.error_agg_error_fatal7_sts -> enable = error1_intr_en_r.error_agg_error_fatal7_en;
    error1_internal_intr_r.error_agg_error_fatal8_sts -> enable = error1_intr_en_r.error_agg_error_fatal8_en;
    error1_internal_intr_r.error_agg_error_fatal9_sts -> enable = error1_intr_en_r.error_agg_error_fatal9_en;
    error1_internal_intr_r.error_agg_error_fatal10_sts -> enable = error1_intr_en_r.error_agg_error_fatal10_en;
    error1_internal_intr_r.error_agg_error_fatal11_sts -> enable = error1_intr_en_r.error_agg_error_fatal11_en;
    error1_internal_intr_r.error_agg_error_fatal12_sts -> enable = error1_intr_en_r.error_agg_error_fatal12_en;
    error1_internal_intr_r.error_agg_error_fatal13_sts -> enable = error1_intr_en_r.error_agg_error_fatal13_en;
    error1_internal_intr_r.error_agg_error_fatal14_sts -> enable = error1_intr_en_r.error_agg_error_fatal14_en;
    error1_internal_intr_r.error_agg_error_fatal15_sts -> enable = error1_intr_en_r.error_agg_error_fatal15_en;
    error1_internal_intr_r.error_agg_error_fatal16_sts -> enable = error1_intr_en_r.error_agg_error_fatal16_en;
    error1_internal_intr_r.error_agg_error_fatal17_sts -> enable = error1_intr_en_r.error_agg_error_fatal17_en;
    error1_internal_intr_r.error_agg_error_fatal18_sts -> enable = error1_intr_en_r.error_agg_error_fatal18_en;
    error1_internal_intr_r.error_agg_error_fatal19_sts -> enable = error1_intr_en_r.error_agg_error_fatal19_en;
    error1_internal_intr_r.error_agg_error_fatal20_sts -> enable = error1_intr_en_r.error_agg_error_fatal20_en;
    error1_internal_intr_r.error_agg_error_fatal21_sts -> enable = error1_intr_en_r.error_agg_error_fatal21_en;
    error1_internal_intr_r.error_agg_error_fatal22_sts -> enable = error1_intr_en_r.error_agg_error_fatal22_en;
    error1_internal_intr_r.error_agg_error_fatal23_sts -> enable = error1_intr_en_r.error_agg_error_fatal23_en;
    error1_internal_intr_r.error_agg_error_fatal24_sts -> enable = error1_intr_en_r.error_agg_error_fatal24_en;
    error1_internal_intr_r.error_agg_error_fatal25_sts -> enable = error1_intr_en_r.error_agg_error_fatal25_en;
    error1_internal_intr_r.error_agg_error_fatal26_sts -> enable = error1_intr_en_r.error_agg_error_fatal26_en;
    error1_internal_intr_r.error_agg_error_fatal27_sts -> enable = error1_intr_en_r.error_agg_error_fatal27_en;
    error1_internal_intr_r.error_agg_error_fatal28_sts -> enable = error1_intr_en_r.error_agg_error_fatal28_en;
    error1_internal_intr_r.error_agg_error_fatal29_sts -> enable = error1_intr_en_r.error_agg_error_fatal29_en;
    error1_internal_intr_r.error_agg_error_fatal30_sts -> enable = error1_intr_en_r.error_agg_error_fatal30_en;
    error1_internal_intr_r.error_agg_error_fatal31_sts -> enable = error1_intr_en_r.error_agg_error_fatal31_en;
    notif0_internal_intr_r.notif_mcu_sram_ecc_cor_sts     -> enable = notif0_intr_en_r.notif_mcu_sram_ecc_cor_en;
    notif0_internal_intr_r.notif_cptra_mcu_reset_req_sts     -> enable = notif0_intr_en_r.notif_cptra_mcu_reset_req_en;
    notif0_internal_intr_r.notif_gen_in_toggle_sts -> enable = notif0_intr_en_r.notif_gen_in_toggle_en;
    notif0_internal_intr_r.notif_mbox0_target_done_sts     -> enable = notif0_intr_en_r.notif_mbox0_target_done_en;
    notif0_internal_intr_r.notif_mbox1_target_done_sts     -> enable = notif0_intr_en_r.notif_mbox1_target_done_en;
    notif0_internal_intr_r.notif_mbox0_cmd_avail_sts     -> enable = notif0_intr_en_r.notif_mbox0_cmd_avail_en;
    notif0_internal_intr_r.notif_mbox1_cmd_avail_sts     -> enable = notif0_intr_en_r.notif_mbox1_cmd_avail_en;
    notif0_internal_intr_r.notif_cptra_mbox_cmd_avail_sts     -> enable = notif0_intr_en_r.notif_cptra_mbox_cmd_avail_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal0_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal0_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal1_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal1_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal2_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal2_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal3_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal3_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal4_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal4_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal5_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal5_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal6_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal6_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal7_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal7_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal8_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal8_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal9_sts  -> enable = notif1_intr_en_r.notif_agg_error_non_fatal9_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal10_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal10_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal11_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal11_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal12_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal12_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal13_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal13_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal14_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal14_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal15_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal15_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal16_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal16_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal17_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal17_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal18_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal18_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal19_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal19_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal20_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal20_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal21_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal21_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal22_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal22_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal23_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal23_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal24_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal24_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal25_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal25_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal26_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal26_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal27_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal27_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal28_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal28_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal29_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal29_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal30_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal30_en;
    notif1_internal_intr_r.notif_agg_error_non_fatal31_sts -> enable = notif1_intr_en_r.notif_agg_error_non_fatal31_en;
    notif0_internal_intr_r.notif_mbox0_ecc_cor_sts  -> enable = notif0_intr_en_r.notif_mbox0_ecc_cor_en;
    notif0_internal_intr_r.notif_mbox1_ecc_cor_sts  -> enable = notif0_intr_en_r.notif_mbox1_ecc_cor_en;
    notif0_internal_intr_r.notif_debug_locked_sts  -> enable = notif0_intr_en_r.notif_debug_locked_en;
    notif0_internal_intr_r.notif_scan_mode_sts     -> enable = notif0_intr_en_r.notif_scan_mode_en;
    notif0_internal_intr_r.notif_mbox0_soc_req_lock_sts  -> enable = notif0_intr_en_r.notif_mbox0_soc_req_lock_en;
    notif0_internal_intr_r.notif_mbox1_soc_req_lock_sts  -> enable = notif0_intr_en_r.notif_mbox1_soc_req_lock_en;

    error0_internal_intr_r.error_internal_sts     -> next   = error0_intr_trig_r.error_internal_trig;
    error0_internal_intr_r.error_mbox0_ecc_unc_sts -> next   = error0_intr_trig_r.error_mbox0_ecc_unc_trig;
    error0_internal_intr_r.error_mbox1_ecc_unc_sts -> next   = error0_intr_trig_r.error_mbox1_ecc_unc_trig;
    error0_internal_intr_r.error_wdt_timer1_timeout_sts -> next   = error0_intr_trig_r.error_wdt_timer1_timeout_trig;
    error0_internal_intr_r.error_wdt_timer2_timeout_sts -> next   = error0_intr_trig_r.error_wdt_timer2_timeout_trig;
    error0_internal_intr_r.error_mcu_sram_dmi_axi_collision_sts -> next   = error0_intr_trig_r.error_mcu_sram_dmi_axi_collision_trig;
    error1_internal_intr_r.error_agg_error_fatal0_sts  -> next = error1_intr_trig_r.error_agg_error_fatal0_trig;
    error1_internal_intr_r.error_agg_error_fatal1_sts  -> next = error1_intr_trig_r.error_agg_error_fatal1_trig;
    error1_internal_intr_r.error_agg_error_fatal2_sts  -> next = error1_intr_trig_r.error_agg_error_fatal2_trig;
    error1_internal_intr_r.error_agg_error_fatal3_sts  -> next = error1_intr_trig_r.error_agg_error_fatal3_trig;
    error1_internal_intr_r.error_agg_error_fatal4_sts  -> next = error1_intr_trig_r.error_agg_error_fatal4_trig;
    error1_internal_intr_r.error_agg_error_fatal5_sts  -> next = error1_intr_trig_r.error_agg_error_fatal5_trig;
    error1_internal_intr_r.error_agg_error_fatal6_sts  -> next = error1_intr_trig_r.error_agg_error_fatal6_trig;
    error1_internal_intr_r.error_agg_error_fatal7_sts  -> next = error1_intr_trig_r.error_agg_error_fatal7_trig;
    error1_internal_intr_r.error_agg_error_fatal8_sts  -> next = error1_intr_trig_r.error_agg_error_fatal8_trig;
    error1_internal_intr_r.error_agg_error_fatal9_sts  -> next = error1_intr_trig_r.error_agg_error_fatal9_trig;
    error1_internal_intr_r.error_agg_error_fatal10_sts -> next = error1_intr_trig_r.error_agg_error_fatal10_trig;
    error1_internal_intr_r.error_agg_error_fatal11_sts -> next = error1_intr_trig_r.error_agg_error_fatal11_trig;
    error1_internal_intr_r.error_agg_error_fatal12_sts -> next = error1_intr_trig_r.error_agg_error_fatal12_trig;
    error1_internal_intr_r.error_agg_error_fatal13_sts -> next = error1_intr_trig_r.error_agg_error_fatal13_trig;
    error1_internal_intr_r.error_agg_error_fatal14_sts -> next = error1_intr_trig_r.error_agg_error_fatal14_trig;
    error1_internal_intr_r.error_agg_error_fatal15_sts -> next = error1_intr_trig_r.error_agg_error_fatal15_trig;
    error1_internal_intr_r.error_agg_error_fatal16_sts -> next = error1_intr_trig_r.error_agg_error_fatal16_trig;
    error1_internal_intr_r.error_agg_error_fatal17_sts -> next = error1_intr_trig_r.error_agg_error_fatal17_trig;
    error1_internal_intr_r.error_agg_error_fatal18_sts -> next = error1_intr_trig_r.error_agg_error_fatal18_trig;
    error1_internal_intr_r.error_agg_error_fatal19_sts -> next = error1_intr_trig_r.error_agg_error_fatal19_trig;
    error1_internal_intr_r.error_agg_error_fatal20_sts -> next = error1_intr_trig_r.error_agg_error_fatal20_trig;
    error1_internal_intr_r.error_agg_error_fatal21_sts -> next = error1_intr_trig_r.error_agg_error_fatal21_trig;
    error1_internal_intr_r.error_agg_error_fatal22_sts -> next = error1_intr_trig_r.error_agg_error_fatal22_trig;
    error1_internal_intr_r.error_agg_error_fatal23_sts -> next = error1_intr_trig_r.error_agg_error_fatal23_trig;
    error1_internal_intr_r.error_agg_error_fatal24_sts -> next = error1_intr_trig_r.error_agg_error_fatal24_trig;
    error1_internal_intr_r.error_agg_error_fatal25_sts -> next = error1_intr_trig_r.error_agg_error_fatal25_trig;
    error1_internal_intr_r.error_agg_error_fatal26_sts -> next = error1_intr_trig_r.error_agg_error_fatal26_trig;
    error1_internal_intr_r.error_agg_error_fatal27_sts -> next = error1_intr_trig_r.error_agg_error_fatal27_trig;
    error1_internal_intr_r.error_agg_error_fatal28_sts -> next = error1_intr_trig_r.error_agg_error_fatal28_trig;
    error1_internal_intr_r.error_agg_error_fatal29_sts -> next = error1_intr_trig_r.error_agg_error_fatal29_trig;
    error1_internal_intr_r.error_agg_error_fatal30_sts -> next = error1_intr_trig_r.error_agg_error_fatal30_trig;
    error1_internal_intr_r.error_agg_error_fatal31_sts -> next = error1_intr_trig_r.error_agg_error_fatal31_trig;
    notif0_internal_intr_r.notif_mcu_sram_ecc_cor_sts     -> next   = notif0_intr_trig_r.notif_mcu_sram_ecc_cor_trig;
    notif0_internal_intr_r.notif_cptra_mcu_reset_req_sts     -> next   = notif0_intr_trig_r.notif_cptra_mcu_reset_req_trig;
    notif0_internal_intr_r.notif_gen_in_toggle_sts -> next   = notif0_intr_trig_r.notif_gen_in_toggle_trig;
    notif0_internal_intr_r.notif_mbox0_target_done_sts     -> next   = notif0_intr_trig_r.notif_mbox0_target_done_trig;
    notif0_internal_intr_r.notif_mbox1_target_done_sts     -> next   = notif0_intr_trig_r.notif_mbox1_target_done_trig;
    notif0_internal_intr_r.notif_mbox0_cmd_avail_sts     -> next   = notif0_intr_trig_r.notif_mbox0_cmd_avail_trig;
    notif0_internal_intr_r.notif_mbox1_cmd_avail_sts     -> next   = notif0_intr_trig_r.notif_mbox1_cmd_avail_trig;
    notif0_internal_intr_r.notif_cptra_mbox_cmd_avail_sts     -> next   = notif0_intr_trig_r.notif_cptra_mbox_cmd_avail_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal0_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal0_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal1_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal1_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal2_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal2_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal3_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal3_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal4_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal4_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal5_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal5_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal6_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal6_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal7_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal7_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal8_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal8_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal9_sts  -> next = notif1_intr_trig_r.notif_agg_error_non_fatal9_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal10_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal10_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal11_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal11_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal12_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal12_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal13_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal13_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal14_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal14_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal15_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal15_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal16_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal16_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal17_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal17_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal18_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal18_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal19_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal19_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal20_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal20_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal21_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal21_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal22_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal22_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal23_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal23_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal24_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal24_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal25_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal25_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal26_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal26_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal27_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal27_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal28_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal28_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal29_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal29_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal30_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal30_trig;
    notif1_internal_intr_r.notif_agg_error_non_fatal31_sts -> next = notif1_intr_trig_r.notif_agg_error_non_fatal31_trig;
    notif0_internal_intr_r.notif_mbox0_ecc_cor_sts  -> next   = notif0_intr_trig_r.notif_mbox0_ecc_cor_trig;
    notif0_internal_intr_r.notif_mbox1_ecc_cor_sts  -> next   = notif0_intr_trig_r.notif_mbox1_ecc_cor_trig;
    notif0_internal_intr_r.notif_debug_locked_sts  -> next   = notif0_intr_trig_r.notif_debug_locked_trig;
    notif0_internal_intr_r.notif_scan_mode_sts     -> next   = notif0_intr_trig_r.notif_scan_mode_trig;
    notif0_internal_intr_r.notif_mbox0_soc_req_lock_sts  -> next   = notif0_intr_trig_r.notif_mbox0_soc_req_lock_trig;
    notif0_internal_intr_r.notif_mbox1_soc_req_lock_sts  -> next   = notif0_intr_trig_r.notif_mbox1_soc_req_lock_trig;

    // NOTE: hwset for events is implicitly defined as module input

    /* ---- Global Interrupt Dynamic Assignments ---- */
    error_global_intr_r.agg_sts0 -> enable = global_intr_en_r.error_en;
    error_global_intr_r.agg_sts1 -> enable = global_intr_en_r.error_en;
    notif_global_intr_r.agg_sts0 -> enable = global_intr_en_r.notif_en;
    notif_global_intr_r.agg_sts1 -> enable = global_intr_en_r.notif_en;

    error_global_intr_r.agg_sts0 -> next = error0_internal_intr_r -> intr;
    error_global_intr_r.agg_sts1 -> next = error1_internal_intr_r -> intr;
    notif_global_intr_r.agg_sts0 -> next = notif0_internal_intr_r -> intr;
    notif_global_intr_r.agg_sts1 -> next = notif1_internal_intr_r -> intr;

    /* ---- Event Statistics Tracker Assignments ---- */
    // NOTE: This method relies upon a "counter" that is set using the
    //       same events that trigger an interrupt, then immediately
    //       self-clearing, which results in a pulse. Must be configured
    //       to be sensitive to the interrupt trigger events for each event.
    //       The output pulse is then used to increment the ACTUAL counter
    error_internal_intr_count_incr_r.pulse -> hwset    = error0_internal_intr_r.error_internal_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_internal_intr_count_incr_r.pulse -> next     = error0_internal_intr_r.error_internal_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_internal_intr_count_incr_r.pulse -> we       = error0_internal_intr_r.error_internal_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_internal_intr_count_incr_r.pulse -> decr     = error_internal_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_internal_intr_count_r.cnt        -> incr     = error_internal_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_mbox0_ecc_unc_intr_count_incr_r.pulse -> hwset    = error0_internal_intr_r.error_mbox0_ecc_unc_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_mbox0_ecc_unc_intr_count_incr_r.pulse -> next     = error0_internal_intr_r.error_mbox0_ecc_unc_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_mbox0_ecc_unc_intr_count_incr_r.pulse -> we       = error0_internal_intr_r.error_mbox0_ecc_unc_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_mbox0_ecc_unc_intr_count_incr_r.pulse -> decr     = error_mbox0_ecc_unc_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_mbox0_ecc_unc_intr_count_r.cnt        -> incr     = error_mbox0_ecc_unc_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_mbox1_ecc_unc_intr_count_incr_r.pulse -> hwset    = error0_internal_intr_r.error_mbox1_ecc_unc_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_mbox1_ecc_unc_intr_count_incr_r.pulse -> next     = error0_internal_intr_r.error_mbox1_ecc_unc_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_mbox1_ecc_unc_intr_count_incr_r.pulse -> we       = error0_internal_intr_r.error_mbox1_ecc_unc_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_mbox1_ecc_unc_intr_count_incr_r.pulse -> decr     = error_mbox1_ecc_unc_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_mbox1_ecc_unc_intr_count_r.cnt        -> incr     = error_mbox1_ecc_unc_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> hwset    = error0_internal_intr_r.error_wdt_timer1_timeout_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> next     = error0_internal_intr_r.error_wdt_timer1_timeout_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> we       = error0_internal_intr_r.error_wdt_timer1_timeout_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_wdt_timer1_timeout_intr_count_incr_r.pulse -> decr     = error_wdt_timer1_timeout_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_wdt_timer1_timeout_intr_count_r.cnt        -> incr     = error_wdt_timer1_timeout_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> hwset    = error0_internal_intr_r.error_wdt_timer2_timeout_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> next     = error0_internal_intr_r.error_wdt_timer2_timeout_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> we       = error0_internal_intr_r.error_wdt_timer2_timeout_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_wdt_timer2_timeout_intr_count_incr_r.pulse -> decr     = error_wdt_timer2_timeout_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_wdt_timer2_timeout_intr_count_r.cnt        -> incr     = error_wdt_timer2_timeout_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit
    
    error_mcu_sram_dmi_axi_collision_intr_count_incr_r.pulse -> hwset    = error0_internal_intr_r.error_mcu_sram_dmi_axi_collision_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_mcu_sram_dmi_axi_collision_intr_count_incr_r.pulse -> next     = error0_internal_intr_r.error_mcu_sram_dmi_axi_collision_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_mcu_sram_dmi_axi_collision_intr_count_incr_r.pulse -> we       = error0_internal_intr_r.error_mcu_sram_dmi_axi_collision_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_mcu_sram_dmi_axi_collision_intr_count_incr_r.pulse -> decr     = error_mcu_sram_dmi_axi_collision_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_mcu_sram_dmi_axi_collision_intr_count_r.cnt        -> incr     = error_mcu_sram_dmi_axi_collision_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit


    error_agg_error_fatal0_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal0_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal0_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal0_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal0_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal0_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal0_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal0_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal0_intr_count_r.cnt        -> incr     = error_agg_error_fatal0_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal1_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal1_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal1_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal1_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal1_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal1_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal1_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal1_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal1_intr_count_r.cnt        -> incr     = error_agg_error_fatal1_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal2_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal2_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal2_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal2_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal2_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal2_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal2_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal2_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal2_intr_count_r.cnt        -> incr     = error_agg_error_fatal2_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal3_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal3_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal3_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal3_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal3_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal3_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal3_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal3_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal3_intr_count_r.cnt        -> incr     = error_agg_error_fatal3_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal4_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal4_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal4_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal4_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal4_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal4_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal4_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal4_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal4_intr_count_r.cnt        -> incr     = error_agg_error_fatal4_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal5_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal5_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal5_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal5_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal5_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal5_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal5_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal5_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal5_intr_count_r.cnt        -> incr     = error_agg_error_fatal5_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal6_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal6_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal6_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal6_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal6_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal6_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal6_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal6_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal6_intr_count_r.cnt        -> incr     = error_agg_error_fatal6_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal7_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal7_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal7_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal7_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal7_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal7_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal7_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal7_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal7_intr_count_r.cnt        -> incr     = error_agg_error_fatal7_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal8_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal8_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal8_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal8_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal8_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal8_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal8_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal8_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal8_intr_count_r.cnt        -> incr     = error_agg_error_fatal8_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal9_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal9_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal9_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal9_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal9_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal9_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal9_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal9_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal9_intr_count_r.cnt        -> incr     = error_agg_error_fatal9_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal10_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal10_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal10_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal10_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal10_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal10_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal10_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal10_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal10_intr_count_r.cnt        -> incr     = error_agg_error_fatal10_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal11_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal11_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal11_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal11_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal11_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal11_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal11_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal11_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal11_intr_count_r.cnt        -> incr     = error_agg_error_fatal11_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal12_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal12_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal12_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal12_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal12_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal12_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal12_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal12_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal12_intr_count_r.cnt        -> incr     = error_agg_error_fatal12_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal13_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal13_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal13_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal13_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal13_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal13_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal13_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal13_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal13_intr_count_r.cnt        -> incr     = error_agg_error_fatal13_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal14_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal14_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal14_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal14_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal14_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal14_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal14_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal14_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal14_intr_count_r.cnt        -> incr     = error_agg_error_fatal14_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal15_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal15_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal15_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal15_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal15_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal15_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal15_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal15_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal15_intr_count_r.cnt        -> incr     = error_agg_error_fatal15_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal16_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal16_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal16_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal16_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal16_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal16_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal16_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal16_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal16_intr_count_r.cnt        -> incr     = error_agg_error_fatal16_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal17_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal17_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal17_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal17_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal17_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal17_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal17_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal17_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal17_intr_count_r.cnt        -> incr     = error_agg_error_fatal17_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal18_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal18_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal18_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal18_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal18_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal18_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal18_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal18_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal18_intr_count_r.cnt        -> incr     = error_agg_error_fatal18_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal19_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal19_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal19_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal19_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal19_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal19_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal19_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal19_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal19_intr_count_r.cnt        -> incr     = error_agg_error_fatal19_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal20_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal20_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal20_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal20_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal20_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal20_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal20_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal20_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal20_intr_count_r.cnt        -> incr     = error_agg_error_fatal20_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal21_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal21_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal21_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal21_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal21_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal21_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal21_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal21_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal21_intr_count_r.cnt        -> incr     = error_agg_error_fatal21_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal22_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal22_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal22_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal22_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal22_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal22_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal22_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal22_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal22_intr_count_r.cnt        -> incr     = error_agg_error_fatal22_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal23_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal23_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal23_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal23_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal23_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal23_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal23_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal23_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal23_intr_count_r.cnt        -> incr     = error_agg_error_fatal23_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal24_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal24_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal24_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal24_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal24_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal24_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal24_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal24_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal24_intr_count_r.cnt        -> incr     = error_agg_error_fatal24_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal25_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal25_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal25_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal25_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal25_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal25_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal25_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal25_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal25_intr_count_r.cnt        -> incr     = error_agg_error_fatal25_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal26_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal26_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal26_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal26_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal26_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal26_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal26_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal26_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal26_intr_count_r.cnt        -> incr     = error_agg_error_fatal26_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal27_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal27_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal27_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal27_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal27_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal27_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal27_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal27_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal27_intr_count_r.cnt        -> incr     = error_agg_error_fatal27_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal28_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal28_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal28_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal28_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal28_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal28_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal28_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal28_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal28_intr_count_r.cnt        -> incr     = error_agg_error_fatal28_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal29_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal29_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal29_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal29_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal29_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal29_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal29_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal29_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal29_intr_count_r.cnt        -> incr     = error_agg_error_fatal29_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal30_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal30_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal30_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal30_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal30_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal30_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal30_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal30_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal30_intr_count_r.cnt        -> incr     = error_agg_error_fatal30_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    error_agg_error_fatal31_intr_count_incr_r.pulse -> hwset    = error1_internal_intr_r.error_agg_error_fatal31_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    error_agg_error_fatal31_intr_count_incr_r.pulse -> next     = error1_internal_intr_r.error_agg_error_fatal31_sts -> next;  // /      as a pulse to increment the intr_count_r register
    error_agg_error_fatal31_intr_count_incr_r.pulse -> we       = error1_internal_intr_r.error_agg_error_fatal31_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    error_agg_error_fatal31_intr_count_incr_r.pulse -> decr     = error_agg_error_fatal31_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    error_agg_error_fatal31_intr_count_r.cnt        -> incr     = error_agg_error_fatal31_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_mcu_sram_ecc_cor_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_mcu_sram_ecc_cor_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_mcu_sram_ecc_cor_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse -> decr     = notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mcu_sram_ecc_cor_intr_count_r.cnt        -> incr     = notif_mcu_sram_ecc_cor_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit
    
    notif_cptra_mcu_reset_req_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_cptra_mcu_reset_req_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_cptra_mcu_reset_req_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_cptra_mcu_reset_req_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_cptra_mcu_reset_req_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_cptra_mcu_reset_req_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_cptra_mcu_reset_req_intr_count_incr_r.pulse -> decr     = notif_cptra_mcu_reset_req_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_cptra_mcu_reset_req_intr_count_r.cnt        -> incr     = notif_cptra_mcu_reset_req_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_gen_in_toggle_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_gen_in_toggle_sts -> hwset; // \_____ Capture both         firmware and hardware triggered events
    notif_gen_in_toggle_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_gen_in_toggle_sts -> next;  // /      as a pulse to        increment the intr_count_r register
    notif_gen_in_toggle_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_gen_in_toggle_sts -> next;  // Generate a pulse from SW    trigger, if set, or default to use the hwset input
    notif_gen_in_toggle_intr_count_incr_r.pulse -> decr  = notif_gen_in_toggle_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_gen_in_toggle_intr_count_r.cnt        -> incr  = notif_gen_in_toggle_intr_count_incr_r.pulse; // Increment coincides with rising edge   of interrupt sts bit



    notif_agg_error_non_fatal0_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal0_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal0_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal0_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal0_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal0_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal0_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal0_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal0_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal0_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal1_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal1_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal1_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal1_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal1_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal1_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal1_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal1_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal1_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal1_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal2_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal2_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal2_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal2_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal2_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal2_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal2_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal2_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal2_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal2_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal3_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal3_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal3_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal3_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal3_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal3_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal3_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal3_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal3_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal3_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal4_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal4_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal4_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal4_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal4_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal4_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal4_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal4_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal4_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal4_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal5_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal5_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal5_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal5_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal5_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal5_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal5_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal5_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal5_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal5_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal6_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal6_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal6_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal6_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal6_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal6_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal6_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal6_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal6_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal6_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal7_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal7_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal7_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal7_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal7_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal7_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal7_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal7_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal7_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal7_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal8_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal8_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal8_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal8_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal8_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal8_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal8_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal8_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal8_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal8_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal9_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal9_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal9_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal9_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal9_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal9_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal9_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal9_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal9_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal9_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal10_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal10_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal10_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal10_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal10_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal10_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal10_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal10_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal10_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal10_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal11_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal11_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal11_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal11_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal11_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal11_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal11_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal11_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal11_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal11_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal12_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal12_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal12_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal12_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal12_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal12_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal12_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal12_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal12_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal12_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal13_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal13_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal13_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal13_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal13_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal13_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal13_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal13_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal13_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal13_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal14_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal14_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal14_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal14_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal14_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal14_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal14_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal14_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal14_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal14_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal15_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal15_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal15_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal15_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal15_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal15_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal15_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal15_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal15_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal15_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal16_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal16_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal16_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal16_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal16_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal16_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal16_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal16_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal16_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal16_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal17_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal17_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal17_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal17_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal17_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal17_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal17_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal17_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal17_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal17_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal18_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal18_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal18_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal18_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal18_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal18_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal18_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal18_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal18_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal18_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal19_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal19_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal19_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal19_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal19_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal19_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal19_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal19_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal19_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal19_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal20_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal20_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal20_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal20_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal20_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal20_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal20_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal20_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal20_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal20_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal21_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal21_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal21_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal21_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal21_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal21_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal21_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal21_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal21_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal21_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal22_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal22_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal22_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal22_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal22_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal22_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal22_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal22_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal22_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal22_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal23_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal23_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal23_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal23_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal23_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal23_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal23_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal23_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal23_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal23_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal24_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal24_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal24_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal24_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal24_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal24_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal24_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal24_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal24_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal24_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal25_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal25_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal25_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal25_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal25_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal25_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal25_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal25_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal25_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal25_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal26_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal26_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal26_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal26_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal26_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal26_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal26_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal26_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal26_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal26_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal27_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal27_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal27_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal27_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal27_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal27_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal27_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal27_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal27_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal27_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal28_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal28_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal28_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal28_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal28_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal28_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal28_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal28_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal28_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal28_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal29_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal29_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal29_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal29_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal29_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal29_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal29_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal29_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal29_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal29_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal30_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal30_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal30_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal30_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal30_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal30_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal30_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal30_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal30_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal30_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_agg_error_non_fatal31_intr_count_incr_r.pulse -> hwset    = notif1_internal_intr_r.notif_agg_error_non_fatal31_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_agg_error_non_fatal31_intr_count_incr_r.pulse -> next     = notif1_internal_intr_r.notif_agg_error_non_fatal31_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_agg_error_non_fatal31_intr_count_incr_r.pulse -> we       = notif1_internal_intr_r.notif_agg_error_non_fatal31_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_agg_error_non_fatal31_intr_count_incr_r.pulse -> decr     = notif_agg_error_non_fatal31_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_agg_error_non_fatal31_intr_count_r.cnt        -> incr     = notif_agg_error_non_fatal31_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit
    
    notif_mbox0_target_done_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_mbox0_target_done_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox0_target_done_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_mbox0_target_done_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox0_target_done_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_mbox0_target_done_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox0_target_done_intr_count_incr_r.pulse -> decr     = notif_mbox0_target_done_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox0_target_done_intr_count_r.cnt        -> incr     = notif_mbox0_target_done_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox1_target_done_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_mbox1_target_done_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox1_target_done_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_mbox1_target_done_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox1_target_done_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_mbox1_target_done_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox1_target_done_intr_count_incr_r.pulse -> decr     = notif_mbox1_target_done_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox1_target_done_intr_count_r.cnt        -> incr     = notif_mbox1_target_done_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox0_cmd_avail_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_mbox0_cmd_avail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox0_cmd_avail_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_mbox0_cmd_avail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox0_cmd_avail_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_mbox0_cmd_avail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox0_cmd_avail_intr_count_incr_r.pulse -> decr     = notif_mbox0_cmd_avail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox0_cmd_avail_intr_count_r.cnt        -> incr     = notif_mbox0_cmd_avail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox1_cmd_avail_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_mbox1_cmd_avail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox1_cmd_avail_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_mbox1_cmd_avail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox1_cmd_avail_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_mbox1_cmd_avail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox1_cmd_avail_intr_count_incr_r.pulse -> decr     = notif_mbox1_cmd_avail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox1_cmd_avail_intr_count_r.cnt        -> incr     = notif_mbox1_cmd_avail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit
    
    notif_cptra_mbox_cmd_avail_intr_count_incr_r.pulse -> hwset    = notif0_internal_intr_r.notif_cptra_mbox_cmd_avail_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_cptra_mbox_cmd_avail_intr_count_incr_r.pulse -> next     = notif0_internal_intr_r.notif_cptra_mbox_cmd_avail_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_cptra_mbox_cmd_avail_intr_count_incr_r.pulse -> we       = notif0_internal_intr_r.notif_cptra_mbox_cmd_avail_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_cptra_mbox_cmd_avail_intr_count_incr_r.pulse -> decr     = notif_cptra_mbox_cmd_avail_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_cptra_mbox_cmd_avail_intr_count_r.cnt        -> incr     = notif_cptra_mbox_cmd_avail_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox0_ecc_cor_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_mbox0_ecc_cor_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox0_ecc_cor_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_mbox0_ecc_cor_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox0_ecc_cor_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_mbox0_ecc_cor_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox0_ecc_cor_intr_count_incr_r.pulse -> decr  = notif_mbox0_ecc_cor_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox0_ecc_cor_intr_count_r.cnt        -> incr  = notif_mbox0_ecc_cor_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox1_ecc_cor_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_mbox1_ecc_cor_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox1_ecc_cor_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_mbox1_ecc_cor_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox1_ecc_cor_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_mbox1_ecc_cor_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox1_ecc_cor_intr_count_incr_r.pulse -> decr  = notif_mbox1_ecc_cor_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox1_ecc_cor_intr_count_r.cnt        -> incr  = notif_mbox1_ecc_cor_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_debug_locked_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_debug_locked_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_debug_locked_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_debug_locked_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_debug_locked_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_debug_locked_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_debug_locked_intr_count_incr_r.pulse -> decr  = notif_debug_locked_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_debug_locked_intr_count_r.cnt        -> incr  = notif_debug_locked_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_scan_mode_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_scan_mode_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_scan_mode_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_scan_mode_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_scan_mode_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_scan_mode_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_scan_mode_intr_count_incr_r.pulse -> decr  = notif_scan_mode_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_scan_mode_intr_count_r.cnt        -> incr  = notif_scan_mode_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox0_soc_req_lock_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_mbox0_soc_req_lock_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox0_soc_req_lock_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_mbox0_soc_req_lock_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox0_soc_req_lock_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_mbox0_soc_req_lock_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox0_soc_req_lock_intr_count_incr_r.pulse -> decr  = notif_mbox0_soc_req_lock_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox0_soc_req_lock_intr_count_r.cnt        -> incr  = notif_mbox0_soc_req_lock_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit

    notif_mbox1_soc_req_lock_intr_count_incr_r.pulse -> hwset = notif0_internal_intr_r.notif_mbox1_soc_req_lock_sts -> hwset; // \_____ Capture both firmware and hardware triggered events
    notif_mbox1_soc_req_lock_intr_count_incr_r.pulse -> next  = notif0_internal_intr_r.notif_mbox1_soc_req_lock_sts -> next;  // /      as a pulse to increment the intr_count_r register
    notif_mbox1_soc_req_lock_intr_count_incr_r.pulse -> we    = notif0_internal_intr_r.notif_mbox1_soc_req_lock_sts -> next;  // Generate a pulse from SW trigger, if set, or default to use the hwset input
    notif_mbox1_soc_req_lock_intr_count_incr_r.pulse -> decr  = notif_mbox1_soc_req_lock_intr_count_incr_r.pulse; // Auto-clear to generate pulse output
    notif_mbox1_soc_req_lock_intr_count_r.cnt        -> incr  = notif_mbox1_soc_req_lock_intr_count_incr_r.pulse; // Increment coincides with rising edge of interrupt sts bit


};

/* -----------------------
 * Register File instance
 * ----------------------- */
intr_block_t intr_block_rf @0x1000;

};
