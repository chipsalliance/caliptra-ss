
// This file was autogenerated by PeakRDL-uvm
package mci_reg_uvm;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    `include "mci_reg_covergroups.svh"
    // Reg - mci_reg::CAPABILITIES
    class mci_reg__CAPABILITIES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__CAPABILITIES_bit_cg NUM_MBOX_bit_cg[4];
        mci_reg__CAPABILITIES_fld_cg fld_cg;
        rand uvm_reg_field NUM_MBOX;

        function new(string name = "mci_reg__CAPABILITIES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.NUM_MBOX = new("NUM_MBOX");
            this.NUM_MBOX.configure(this, 4, 0, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(NUM_MBOX_bit_cg[bt]) NUM_MBOX_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__CAPABILITIES

    // Reg - mci_reg::HW_REV_ID
    class mci_reg__HW_REV_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__HW_REV_ID_bit_cg MC_GENERATION_bit_cg[16];
        mci_reg__HW_REV_ID_bit_cg SOC_STEPPING_ID_bit_cg[16];
        mci_reg__HW_REV_ID_fld_cg fld_cg;
        rand uvm_reg_field MC_GENERATION;
        rand uvm_reg_field SOC_STEPPING_ID;

        function new(string name = "mci_reg__HW_REV_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.MC_GENERATION = new("MC_GENERATION");
            this.MC_GENERATION.configure(this, 16, 0, "RO", 0, 'h1000, 1, 1, 0);
            this.SOC_STEPPING_ID = new("SOC_STEPPING_ID");
            this.SOC_STEPPING_ID.configure(this, 16, 16, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(MC_GENERATION_bit_cg[bt]) MC_GENERATION_bit_cg[bt] = new();
                foreach(SOC_STEPPING_ID_bit_cg[bt]) SOC_STEPPING_ID_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__HW_REV_ID

    // Reg - mci_reg::FW_REV_ID
    class mci_reg__FW_REV_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FW_REV_ID_bit_cg REV_ID_bit_cg[32];
        mci_reg__FW_REV_ID_fld_cg fld_cg;
        rand uvm_reg_field REV_ID;

        function new(string name = "mci_reg__FW_REV_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.REV_ID = new("REV_ID");
            this.REV_ID.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(REV_ID_bit_cg[bt]) REV_ID_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FW_REV_ID

    // Reg - mci_reg::HW_CONFIG
    class mci_reg__HW_CONFIG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__HW_CONFIG_bit_cg RSVD_en_bit_cg[1];
        mci_reg__HW_CONFIG_fld_cg fld_cg;
        rand uvm_reg_field RSVD_en;

        function new(string name = "mci_reg__HW_CONFIG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RSVD_en = new("RSVD_en");
            this.RSVD_en.configure(this, 1, 0, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RSVD_en_bit_cg[bt]) RSVD_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__HW_CONFIG

    // Reg - mci_reg::BOOT_STATUS
    class mci_reg__BOOT_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__BOOT_STATUS_bit_cg status_bit_cg[32];
        mci_reg__BOOT_STATUS_fld_cg fld_cg;
        rand uvm_reg_field status;

        function new(string name = "mci_reg__BOOT_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.status = new("status");
            this.status.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(status_bit_cg[bt]) status_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__BOOT_STATUS

    // Reg - mci_reg::FLOW_STATUS
    class mci_reg__FLOW_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FLOW_STATUS_bit_cg status_bit_cg[24];
        mci_reg__FLOW_STATUS_bit_cg rsvd_bit_cg[3];
        mci_reg__FLOW_STATUS_bit_cg boot_fsm_ps_bit_cg[5];
        mci_reg__FLOW_STATUS_fld_cg fld_cg;
        rand uvm_reg_field status;
        rand uvm_reg_field rsvd;
        rand uvm_reg_field boot_fsm_ps;

        function new(string name = "mci_reg__FLOW_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.status = new("status");
            this.status.configure(this, 24, 0, "RW", 0, 'h0, 1, 1, 0);
            this.rsvd = new("rsvd");
            this.rsvd.configure(this, 3, 24, "RO", 0, 'h0, 1, 1, 0);
            this.boot_fsm_ps = new("boot_fsm_ps");
            this.boot_fsm_ps.configure(this, 5, 27, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(status_bit_cg[bt]) status_bit_cg[bt] = new();
                foreach(rsvd_bit_cg[bt]) rsvd_bit_cg[bt] = new();
                foreach(boot_fsm_ps_bit_cg[bt]) boot_fsm_ps_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FLOW_STATUS

    // Reg - mci_reg::RESET_REASON
    class mci_reg__RESET_REASON extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__RESET_REASON_bit_cg FW_UPD_RESET_bit_cg[1];
        mci_reg__RESET_REASON_bit_cg WARM_RESET_bit_cg[1];
        mci_reg__RESET_REASON_fld_cg fld_cg;
        rand uvm_reg_field FW_UPD_RESET;
        rand uvm_reg_field WARM_RESET;

        function new(string name = "mci_reg__RESET_REASON");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.FW_UPD_RESET = new("FW_UPD_RESET");
            this.FW_UPD_RESET.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            this.WARM_RESET = new("WARM_RESET");
            this.WARM_RESET.configure(this, 1, 1, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(FW_UPD_RESET_bit_cg[bt]) FW_UPD_RESET_bit_cg[bt] = new();
                foreach(WARM_RESET_bit_cg[bt]) WARM_RESET_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__RESET_REASON

    // Reg - mci_reg::HW_ERROR_FATAL
    class mci_reg__HW_ERROR_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__HW_ERROR_FATAL_bit_cg RSVD_bit_cg[1];
        mci_reg__HW_ERROR_FATAL_fld_cg fld_cg;
        rand uvm_reg_field RSVD;

        function new(string name = "mci_reg__HW_ERROR_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RSVD = new("RSVD");
            this.RSVD.configure(this, 1, 0, "W1C", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RSVD_bit_cg[bt]) RSVD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__HW_ERROR_FATAL

    // Reg - mci_reg::HW_ERROR_NON_FATAL
    class mci_reg__HW_ERROR_NON_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__HW_ERROR_NON_FATAL_bit_cg RSVD_bit_cg[1];
        mci_reg__HW_ERROR_NON_FATAL_fld_cg fld_cg;
        rand uvm_reg_field RSVD;

        function new(string name = "mci_reg__HW_ERROR_NON_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.RSVD = new("RSVD");
            this.RSVD.configure(this, 1, 0, "W1C", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(RSVD_bit_cg[bt]) RSVD_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__HW_ERROR_NON_FATAL

    // Reg - mci_reg::FW_ERROR_FATAL
    class mci_reg__FW_ERROR_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FW_ERROR_FATAL_bit_cg error_code_bit_cg[32];
        mci_reg__FW_ERROR_FATAL_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "mci_reg__FW_ERROR_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FW_ERROR_FATAL

    // Reg - mci_reg::FW_ERROR_NON_FATAL
    class mci_reg__FW_ERROR_NON_FATAL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FW_ERROR_NON_FATAL_bit_cg error_code_bit_cg[32];
        mci_reg__FW_ERROR_NON_FATAL_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "mci_reg__FW_ERROR_NON_FATAL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FW_ERROR_NON_FATAL

    // Reg - mci_reg::HW_ERROR_ENC
    class mci_reg__HW_ERROR_ENC extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__HW_ERROR_ENC_bit_cg error_code_bit_cg[32];
        mci_reg__HW_ERROR_ENC_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "mci_reg__HW_ERROR_ENC");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__HW_ERROR_ENC

    // Reg - mci_reg::FW_ERROR_ENC
    class mci_reg__FW_ERROR_ENC extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FW_ERROR_ENC_bit_cg error_code_bit_cg[32];
        mci_reg__FW_ERROR_ENC_fld_cg fld_cg;
        rand uvm_reg_field error_code;

        function new(string name = "mci_reg__FW_ERROR_ENC");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_code = new("error_code");
            this.error_code.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_code_bit_cg[bt]) error_code_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FW_ERROR_ENC

    // Reg - mci_reg::FW_EXTENDED_ERROR_INFO
    class mci_reg__FW_EXTENDED_ERROR_INFO extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FW_EXTENDED_ERROR_INFO_bit_cg error_info_bit_cg[32];
        mci_reg__FW_EXTENDED_ERROR_INFO_fld_cg fld_cg;
        rand uvm_reg_field error_info;

        function new(string name = "mci_reg__FW_EXTENDED_ERROR_INFO");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.error_info = new("error_info");
            this.error_info.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(error_info_bit_cg[bt]) error_info_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FW_EXTENDED_ERROR_INFO

    // Reg - mci_reg::WDT_TIMER1_EN
    class mci_reg__WDT_TIMER1_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_TIMER1_EN_bit_cg timer1_en_bit_cg[1];
        mci_reg__WDT_TIMER1_EN_fld_cg fld_cg;
        rand uvm_reg_field timer1_en;

        function new(string name = "mci_reg__WDT_TIMER1_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer1_en = new("timer1_en");
            this.timer1_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer1_en_bit_cg[bt]) timer1_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_TIMER1_EN

    // Reg - mci_reg::WDT_TIMER1_CTRL
    class mci_reg__WDT_TIMER1_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_TIMER1_CTRL_bit_cg timer1_restart_bit_cg[1];
        mci_reg__WDT_TIMER1_CTRL_fld_cg fld_cg;
        rand uvm_reg_field timer1_restart;

        function new(string name = "mci_reg__WDT_TIMER1_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer1_restart = new("timer1_restart");
            this.timer1_restart.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer1_restart_bit_cg[bt]) timer1_restart_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_TIMER1_CTRL

    // Reg - mci_reg::WDT_TIMER1_TIMEOUT_PERIOD
    class mci_reg__WDT_TIMER1_TIMEOUT_PERIOD extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_TIMER1_TIMEOUT_PERIOD_bit_cg timer1_timeout_period_bit_cg[32];
        mci_reg__WDT_TIMER1_TIMEOUT_PERIOD_fld_cg fld_cg;
        rand uvm_reg_field timer1_timeout_period;

        function new(string name = "mci_reg__WDT_TIMER1_TIMEOUT_PERIOD");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer1_timeout_period = new("timer1_timeout_period");
            this.timer1_timeout_period.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer1_timeout_period_bit_cg[bt]) timer1_timeout_period_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_TIMER1_TIMEOUT_PERIOD

    // Reg - mci_reg::WDT_TIMER2_EN
    class mci_reg__WDT_TIMER2_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_TIMER2_EN_bit_cg timer2_en_bit_cg[1];
        mci_reg__WDT_TIMER2_EN_fld_cg fld_cg;
        rand uvm_reg_field timer2_en;

        function new(string name = "mci_reg__WDT_TIMER2_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer2_en = new("timer2_en");
            this.timer2_en.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer2_en_bit_cg[bt]) timer2_en_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_TIMER2_EN

    // Reg - mci_reg::WDT_TIMER2_CTRL
    class mci_reg__WDT_TIMER2_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_TIMER2_CTRL_bit_cg timer2_restart_bit_cg[1];
        mci_reg__WDT_TIMER2_CTRL_fld_cg fld_cg;
        rand uvm_reg_field timer2_restart;

        function new(string name = "mci_reg__WDT_TIMER2_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer2_restart = new("timer2_restart");
            this.timer2_restart.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer2_restart_bit_cg[bt]) timer2_restart_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_TIMER2_CTRL

    // Reg - mci_reg::WDT_TIMER2_TIMEOUT_PERIOD
    class mci_reg__WDT_TIMER2_TIMEOUT_PERIOD extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_TIMER2_TIMEOUT_PERIOD_bit_cg timer2_timeout_period_bit_cg[32];
        mci_reg__WDT_TIMER2_TIMEOUT_PERIOD_fld_cg fld_cg;
        rand uvm_reg_field timer2_timeout_period;

        function new(string name = "mci_reg__WDT_TIMER2_TIMEOUT_PERIOD");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.timer2_timeout_period = new("timer2_timeout_period");
            this.timer2_timeout_period.configure(this, 32, 0, "RW", 0, 'hffffffff, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(timer2_timeout_period_bit_cg[bt]) timer2_timeout_period_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_TIMER2_TIMEOUT_PERIOD

    // Reg - mci_reg::WDT_STATUS
    class mci_reg__WDT_STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_STATUS_bit_cg t1_timeout_bit_cg[1];
        mci_reg__WDT_STATUS_bit_cg t2_timeout_bit_cg[1];
        mci_reg__WDT_STATUS_fld_cg fld_cg;
        rand uvm_reg_field t1_timeout;
        rand uvm_reg_field t2_timeout;

        function new(string name = "mci_reg__WDT_STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.t1_timeout = new("t1_timeout");
            this.t1_timeout.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            this.t2_timeout = new("t2_timeout");
            this.t2_timeout.configure(this, 1, 1, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(t1_timeout_bit_cg[bt]) t1_timeout_bit_cg[bt] = new();
                foreach(t2_timeout_bit_cg[bt]) t2_timeout_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_STATUS

    // Reg - mci_reg::WDT_CFG
    class mci_reg__WDT_CFG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__WDT_CFG_bit_cg TIMEOUT_bit_cg[32];
        mci_reg__WDT_CFG_fld_cg fld_cg;
        rand uvm_reg_field TIMEOUT;

        function new(string name = "mci_reg__WDT_CFG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.TIMEOUT = new("TIMEOUT");
            this.TIMEOUT.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(TIMEOUT_bit_cg[bt]) TIMEOUT_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__WDT_CFG

    // Reg - mci_reg::MCU_TIMER_CONFIG
    class mci_reg__MCU_TIMER_CONFIG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MCU_TIMER_CONFIG_bit_cg clk_period_bit_cg[32];
        mci_reg__MCU_TIMER_CONFIG_fld_cg fld_cg;
        rand uvm_reg_field clk_period;

        function new(string name = "mci_reg__MCU_TIMER_CONFIG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.clk_period = new("clk_period");
            this.clk_period.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(clk_period_bit_cg[bt]) clk_period_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MCU_TIMER_CONFIG

    // Reg - mci_reg::MCU_CLK_GATING_EN
    class mci_reg__MCU_CLK_GATING_EN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MCU_CLK_GATING_EN_bit_cg FIXME_bit_cg[1];
        mci_reg__MCU_CLK_GATING_EN_fld_cg fld_cg;
        rand uvm_reg_field FIXME;

        function new(string name = "mci_reg__MCU_CLK_GATING_EN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.FIXME = new("FIXME");
            this.FIXME.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(FIXME_bit_cg[bt]) FIXME_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MCU_CLK_GATING_EN

    // Reg - mci_reg::MCU_RV_MTIME_L
    class mci_reg__MCU_RV_MTIME_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MCU_RV_MTIME_L_bit_cg count_l_bit_cg[32];
        mci_reg__MCU_RV_MTIME_L_fld_cg fld_cg;
        rand uvm_reg_field count_l;

        function new(string name = "mci_reg__MCU_RV_MTIME_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.count_l = new("count_l");
            this.count_l.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(count_l_bit_cg[bt]) count_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MCU_RV_MTIME_L

    // Reg - mci_reg::MCU_RV_MTIME_H
    class mci_reg__MCU_RV_MTIME_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MCU_RV_MTIME_H_bit_cg count_h_bit_cg[32];
        mci_reg__MCU_RV_MTIME_H_fld_cg fld_cg;
        rand uvm_reg_field count_h;

        function new(string name = "mci_reg__MCU_RV_MTIME_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.count_h = new("count_h");
            this.count_h.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(count_h_bit_cg[bt]) count_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MCU_RV_MTIME_H

    // Reg - mci_reg::MCU_RV_MTIMECMP_L
    class mci_reg__MCU_RV_MTIMECMP_L extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MCU_RV_MTIMECMP_L_bit_cg compare_l_bit_cg[32];
        mci_reg__MCU_RV_MTIMECMP_L_fld_cg fld_cg;
        rand uvm_reg_field compare_l;

        function new(string name = "mci_reg__MCU_RV_MTIMECMP_L");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.compare_l = new("compare_l");
            this.compare_l.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(compare_l_bit_cg[bt]) compare_l_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MCU_RV_MTIMECMP_L

    // Reg - mci_reg::MCU_RV_MTIMECMP_H
    class mci_reg__MCU_RV_MTIMECMP_H extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MCU_RV_MTIMECMP_H_bit_cg compare_h_bit_cg[32];
        mci_reg__MCU_RV_MTIMECMP_H_fld_cg fld_cg;
        rand uvm_reg_field compare_h;

        function new(string name = "mci_reg__MCU_RV_MTIMECMP_H");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.compare_h = new("compare_h");
            this.compare_h.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(compare_h_bit_cg[bt]) compare_h_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MCU_RV_MTIMECMP_H

    // Reg - mci_reg::RESET_REQUEST
    class mci_reg__RESET_REQUEST extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__RESET_REQUEST_bit_cg req_bit_cg[1];
        mci_reg__RESET_REQUEST_bit_cg clr_bit_cg[1];
        mci_reg__RESET_REQUEST_fld_cg fld_cg;
        rand uvm_reg_field req;
        rand uvm_reg_field clr;

        function new(string name = "mci_reg__RESET_REQUEST");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.req = new("req");
            this.req.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            this.clr = new("clr");
            this.clr.configure(this, 1, 1, "W1S", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(req_bit_cg[bt]) req_bit_cg[bt] = new();
                foreach(clr_bit_cg[bt]) clr_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__RESET_REQUEST

    // Reg - mci_reg::RESET_ACK
    class mci_reg__RESET_ACK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__RESET_ACK_bit_cg ack_bit_cg[1];
        mci_reg__RESET_ACK_fld_cg fld_cg;
        rand uvm_reg_field ack;

        function new(string name = "mci_reg__RESET_ACK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ack = new("ack");
            this.ack.configure(this, 1, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ack_bit_cg[bt]) ack_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__RESET_ACK

    // Reg - mci_reg::CALIPTRA_BOOT_GO
    class mci_reg__CALIPTRA_BOOT_GO extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__CALIPTRA_BOOT_GO_bit_cg go_bit_cg[1];
        mci_reg__CALIPTRA_BOOT_GO_fld_cg fld_cg;
        rand uvm_reg_field go;

        function new(string name = "mci_reg__CALIPTRA_BOOT_GO");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.go = new("go");
            this.go.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(go_bit_cg[bt]) go_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__CALIPTRA_BOOT_GO

    // Reg - mci_reg::CALIPTRA_AXI_ID
    class mci_reg__CALIPTRA_AXI_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__CALIPTRA_AXI_ID_bit_cg id_bit_cg[1];
        mci_reg__CALIPTRA_AXI_ID_fld_cg fld_cg;
        rand uvm_reg_field id;

        function new(string name = "mci_reg__CALIPTRA_AXI_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.id = new("id");
            this.id.configure(this, 1, 0, "RO", 1, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(id_bit_cg[bt]) id_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__CALIPTRA_AXI_ID

    // Reg - mci_reg::FW_SRAM_EXEC_REGION_SIZE
    class mci_reg__FW_SRAM_EXEC_REGION_SIZE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FW_SRAM_EXEC_REGION_SIZE_bit_cg size_bit_cg[1];
        mci_reg__FW_SRAM_EXEC_REGION_SIZE_fld_cg fld_cg;
        rand uvm_reg_field size;

        function new(string name = "mci_reg__FW_SRAM_EXEC_REGION_SIZE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.size = new("size");
            this.size.configure(this, 1, 0, "RW", 0, 'h0, 0, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(size_bit_cg[bt]) size_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FW_SRAM_EXEC_REGION_SIZE

    // Reg - mci_reg::RUNTIME_LOCK
    class mci_reg__RUNTIME_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__RUNTIME_LOCK_bit_cg lock_bit_cg[1];
        mci_reg__RUNTIME_LOCK_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "mci_reg__RUNTIME_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__RUNTIME_LOCK

    // Reg - mci_reg::MBOX0_VALID_AXI_ID
    class mci_reg__MBOX0_VALID_AXI_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MBOX0_VALID_AXI_ID_bit_cg id_bit_cg[32];
        mci_reg__MBOX0_VALID_AXI_ID_fld_cg fld_cg;
        rand uvm_reg_field id;

        function new(string name = "mci_reg__MBOX0_VALID_AXI_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.id = new("id");
            this.id.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(id_bit_cg[bt]) id_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MBOX0_VALID_AXI_ID

    // Reg - mci_reg::MBOX0_VALID_AXI_ID_LOCK
    class mci_reg__MBOX0_VALID_AXI_ID_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MBOX0_VALID_AXI_ID_LOCK_bit_cg lock_bit_cg[1];
        mci_reg__MBOX0_VALID_AXI_ID_LOCK_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "mci_reg__MBOX0_VALID_AXI_ID_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MBOX0_VALID_AXI_ID_LOCK

    // Reg - mci_reg::MBOX1_VALID_AXI_ID
    class mci_reg__MBOX1_VALID_AXI_ID extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MBOX1_VALID_AXI_ID_bit_cg id_bit_cg[32];
        mci_reg__MBOX1_VALID_AXI_ID_fld_cg fld_cg;
        rand uvm_reg_field id;

        function new(string name = "mci_reg__MBOX1_VALID_AXI_ID");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.id = new("id");
            this.id.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(id_bit_cg[bt]) id_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MBOX1_VALID_AXI_ID

    // Reg - mci_reg::MBOX1_VALID_AXI_ID_LOCK
    class mci_reg__MBOX1_VALID_AXI_ID_LOCK extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__MBOX1_VALID_AXI_ID_LOCK_bit_cg lock_bit_cg[1];
        mci_reg__MBOX1_VALID_AXI_ID_LOCK_fld_cg fld_cg;
        rand uvm_reg_field lock;

        function new(string name = "mci_reg__MBOX1_VALID_AXI_ID_LOCK");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock = new("lock");
            this.lock.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_bit_cg[bt]) lock_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__MBOX1_VALID_AXI_ID_LOCK

    // Reg - mci_reg::GENERIC_INPUT_WIRES
    class mci_reg__GENERIC_INPUT_WIRES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__GENERIC_INPUT_WIRES_bit_cg wires_bit_cg[32];
        mci_reg__GENERIC_INPUT_WIRES_fld_cg fld_cg;
        rand uvm_reg_field wires;

        function new(string name = "mci_reg__GENERIC_INPUT_WIRES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.wires = new("wires");
            this.wires.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(wires_bit_cg[bt]) wires_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__GENERIC_INPUT_WIRES

    // Reg - mci_reg::GENERIC_OUTPUT_WIRES
    class mci_reg__GENERIC_OUTPUT_WIRES extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__GENERIC_OUTPUT_WIRES_bit_cg wires_bit_cg[32];
        mci_reg__GENERIC_OUTPUT_WIRES_fld_cg fld_cg;
        rand uvm_reg_field wires;

        function new(string name = "mci_reg__GENERIC_OUTPUT_WIRES");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.wires = new("wires");
            this.wires.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(wires_bit_cg[bt]) wires_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__GENERIC_OUTPUT_WIRES

    // Reg - mci_reg::DEBUG_IN
    class mci_reg__DEBUG_IN extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__DEBUG_IN_bit_cg FIXME_bit_cg[1];
        mci_reg__DEBUG_IN_fld_cg fld_cg;
        rand uvm_reg_field FIXME;

        function new(string name = "mci_reg__DEBUG_IN");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.FIXME = new("FIXME");
            this.FIXME.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(FIXME_bit_cg[bt]) FIXME_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__DEBUG_IN

    // Reg - mci_reg::DEBUG_OUT
    class mci_reg__DEBUG_OUT extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__DEBUG_OUT_bit_cg FIXME_bit_cg[1];
        mci_reg__DEBUG_OUT_fld_cg fld_cg;
        rand uvm_reg_field FIXME;

        function new(string name = "mci_reg__DEBUG_OUT");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.FIXME = new("FIXME");
            this.FIXME.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(FIXME_bit_cg[bt]) FIXME_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__DEBUG_OUT

    // Reg - mci_reg::FUSE_WR_DONE
    class mci_reg__FUSE_WR_DONE extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__FUSE_WR_DONE_bit_cg done_bit_cg[1];
        mci_reg__FUSE_WR_DONE_fld_cg fld_cg;
        rand uvm_reg_field done;

        function new(string name = "mci_reg__FUSE_WR_DONE");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.done = new("done");
            this.done.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(done_bit_cg[bt]) done_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__FUSE_WR_DONE

    // Reg - mci_reg::PROD_DEBUG_UNLOCK_PK_HASH_REG
    class mci_reg__PROD_DEBUG_UNLOCK_PK_HASH_REG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__PROD_DEBUG_UNLOCK_PK_HASH_REG_bit_cg hash_bit_cg[32];
        mci_reg__PROD_DEBUG_UNLOCK_PK_HASH_REG_fld_cg fld_cg;
        rand uvm_reg_field hash;

        function new(string name = "mci_reg__PROD_DEBUG_UNLOCK_PK_HASH_REG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.hash = new("hash");
            this.hash.configure(this, 32, 0, "RW", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(hash_bit_cg[bt]) hash_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__PROD_DEBUG_UNLOCK_PK_HASH_REG

    // Reg - mci_reg::STICKY_DATA_VAULT_CTRL
    class mci_reg__STICKY_DATA_VAULT_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__STICKY_DATA_VAULT_CTRL_bit_cg lock_entry_bit_cg[1];
        mci_reg__STICKY_DATA_VAULT_CTRL_fld_cg fld_cg;
        rand uvm_reg_field lock_entry;

        function new(string name = "mci_reg__STICKY_DATA_VAULT_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock_entry = new("lock_entry");
            this.lock_entry.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_entry_bit_cg[bt]) lock_entry_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__STICKY_DATA_VAULT_CTRL

    // Reg - mci_reg::STICKY_DATA_VAULT_ENTRY
    class mci_reg__STICKY_DATA_VAULT_ENTRY extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__STICKY_DATA_VAULT_ENTRY_bit_cg lock_entry_bit_cg[1];
        mci_reg__STICKY_DATA_VAULT_ENTRY_fld_cg fld_cg;
        rand uvm_reg_field lock_entry;

        function new(string name = "mci_reg__STICKY_DATA_VAULT_ENTRY");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock_entry = new("lock_entry");
            this.lock_entry.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_entry_bit_cg[bt]) lock_entry_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__STICKY_DATA_VAULT_ENTRY

    // Reg - mci_reg::DATA_VAULT_CTRL
    class mci_reg__DATA_VAULT_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__DATA_VAULT_CTRL_bit_cg lock_entry_bit_cg[1];
        mci_reg__DATA_VAULT_CTRL_fld_cg fld_cg;
        rand uvm_reg_field lock_entry;

        function new(string name = "mci_reg__DATA_VAULT_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock_entry = new("lock_entry");
            this.lock_entry.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_entry_bit_cg[bt]) lock_entry_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__DATA_VAULT_CTRL

    // Reg - mci_reg::DATA_VAULT_ENTRY
    class mci_reg__DATA_VAULT_ENTRY extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__DATA_VAULT_ENTRY_bit_cg lock_entry_bit_cg[1];
        mci_reg__DATA_VAULT_ENTRY_fld_cg fld_cg;
        rand uvm_reg_field lock_entry;

        function new(string name = "mci_reg__DATA_VAULT_ENTRY");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock_entry = new("lock_entry");
            this.lock_entry.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_entry_bit_cg[bt]) lock_entry_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__DATA_VAULT_ENTRY

    // Reg - mci_reg::STICKY_LOCKABLE_SCRATCH_REG_CTRL
    class mci_reg__STICKY_LOCKABLE_SCRATCH_REG_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__STICKY_LOCKABLE_SCRATCH_REG_CTRL_bit_cg lock_entry_bit_cg[1];
        mci_reg__STICKY_LOCKABLE_SCRATCH_REG_CTRL_fld_cg fld_cg;
        rand uvm_reg_field lock_entry;

        function new(string name = "mci_reg__STICKY_LOCKABLE_SCRATCH_REG_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock_entry = new("lock_entry");
            this.lock_entry.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_entry_bit_cg[bt]) lock_entry_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__STICKY_LOCKABLE_SCRATCH_REG_CTRL

    // Reg - mci_reg::STICKY_LOCKABLE_SCRATCH_REG
    class mci_reg__STICKY_LOCKABLE_SCRATCH_REG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__STICKY_LOCKABLE_SCRATCH_REG_bit_cg data_bit_cg[32];
        mci_reg__STICKY_LOCKABLE_SCRATCH_REG_fld_cg fld_cg;
        rand uvm_reg_field data;

        function new(string name = "mci_reg__STICKY_LOCKABLE_SCRATCH_REG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.data = new("data");
            this.data.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(data_bit_cg[bt]) data_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__STICKY_LOCKABLE_SCRATCH_REG

    // Reg - mci_reg::LOCKABLE_SCRATCH_REG_CTRL
    class mci_reg__LOCKABLE_SCRATCH_REG_CTRL extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__LOCKABLE_SCRATCH_REG_CTRL_bit_cg lock_entry_bit_cg[1];
        mci_reg__LOCKABLE_SCRATCH_REG_CTRL_fld_cg fld_cg;
        rand uvm_reg_field lock_entry;

        function new(string name = "mci_reg__LOCKABLE_SCRATCH_REG_CTRL");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.lock_entry = new("lock_entry");
            this.lock_entry.configure(this, 1, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(lock_entry_bit_cg[bt]) lock_entry_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__LOCKABLE_SCRATCH_REG_CTRL

    // Reg - mci_reg::LOCKABLE_SCRATCH_REG
    class mci_reg__LOCKABLE_SCRATCH_REG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__LOCKABLE_SCRATCH_REG_bit_cg data_bit_cg[32];
        mci_reg__LOCKABLE_SCRATCH_REG_fld_cg fld_cg;
        rand uvm_reg_field data;

        function new(string name = "mci_reg__LOCKABLE_SCRATCH_REG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.data = new("data");
            this.data.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(data_bit_cg[bt]) data_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__LOCKABLE_SCRATCH_REG

    // Reg - mci_reg::NON_STICKY_GENERIC_SCRATCH_REG
    class mci_reg__NON_STICKY_GENERIC_SCRATCH_REG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        mci_reg__NON_STICKY_GENERIC_SCRATCH_REG_bit_cg data_bit_cg[32];
        mci_reg__NON_STICKY_GENERIC_SCRATCH_REG_fld_cg fld_cg;
        rand uvm_reg_field data;

        function new(string name = "mci_reg__NON_STICKY_GENERIC_SCRATCH_REG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.data = new("data");
            this.data.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(data_bit_cg[bt]) data_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : mci_reg__NON_STICKY_GENERIC_SCRATCH_REG

    // Addrmap - mci_reg
    class mci_reg extends uvm_reg_block;
        rand mci_reg__CAPABILITIES CAPABILITIES;
        rand mci_reg__HW_REV_ID HW_REV_ID;
        rand mci_reg__FW_REV_ID FW_REV_ID[2];
        rand mci_reg__HW_CONFIG HW_CONFIG;
        rand mci_reg__BOOT_STATUS BOOT_STATUS;
        rand mci_reg__FLOW_STATUS FLOW_STATUS;
        rand mci_reg__RESET_REASON RESET_REASON;
        rand mci_reg__HW_ERROR_FATAL HW_ERROR_FATAL;
        rand mci_reg__HW_ERROR_NON_FATAL HW_ERROR_NON_FATAL;
        rand mci_reg__FW_ERROR_FATAL FW_ERROR_FATAL;
        rand mci_reg__FW_ERROR_NON_FATAL FW_ERROR_NON_FATAL;
        rand mci_reg__HW_ERROR_ENC HW_ERROR_ENC;
        rand mci_reg__FW_ERROR_ENC FW_ERROR_ENC;
        rand mci_reg__FW_EXTENDED_ERROR_INFO FW_EXTENDED_ERROR_INFO[8];
        rand mci_reg__WDT_TIMER1_EN WDT_TIMER1_EN;
        rand mci_reg__WDT_TIMER1_CTRL WDT_TIMER1_CTRL;
        rand mci_reg__WDT_TIMER1_TIMEOUT_PERIOD WDT_TIMER1_TIMEOUT_PERIOD[2];
        rand mci_reg__WDT_TIMER2_EN WDT_TIMER2_EN;
        rand mci_reg__WDT_TIMER2_CTRL WDT_TIMER2_CTRL;
        rand mci_reg__WDT_TIMER2_TIMEOUT_PERIOD WDT_TIMER2_TIMEOUT_PERIOD[2];
        rand mci_reg__WDT_STATUS WDT_STATUS;
        rand mci_reg__WDT_CFG WDT_CFG[2];
        rand mci_reg__MCU_TIMER_CONFIG MCU_TIMER_CONFIG;
        rand mci_reg__MCU_CLK_GATING_EN MCU_CLK_GATING_EN;
        rand mci_reg__MCU_RV_MTIME_L MCU_RV_MTIME_L;
        rand mci_reg__MCU_RV_MTIME_H MCU_RV_MTIME_H;
        rand mci_reg__MCU_RV_MTIMECMP_L MCU_RV_MTIMECMP_L;
        rand mci_reg__MCU_RV_MTIMECMP_H MCU_RV_MTIMECMP_H;
        rand mci_reg__RESET_REQUEST RESET_REQUEST;
        rand mci_reg__RESET_ACK RESET_ACK;
        rand mci_reg__CALIPTRA_BOOT_GO CALIPTRA_BOOT_GO;
        rand mci_reg__CALIPTRA_AXI_ID CALIPTRA_AXI_ID;
        rand mci_reg__FW_SRAM_EXEC_REGION_SIZE FW_SRAM_EXEC_REGION_SIZE;
        rand mci_reg__RUNTIME_LOCK RUNTIME_LOCK;
        rand mci_reg__MBOX0_VALID_AXI_ID MBOX0_VALID_AXI_ID[5];
        rand mci_reg__MBOX0_VALID_AXI_ID_LOCK MBOX0_VALID_AXI_ID_LOCK[5];
        rand mci_reg__MBOX1_VALID_AXI_ID MBOX1_VALID_AXI_ID[5];
        rand mci_reg__MBOX1_VALID_AXI_ID_LOCK MBOX1_VALID_AXI_ID_LOCK[5];
        rand mci_reg__GENERIC_INPUT_WIRES GENERIC_INPUT_WIRES[2];
        rand mci_reg__GENERIC_OUTPUT_WIRES GENERIC_OUTPUT_WIRES[2];
        rand mci_reg__DEBUG_IN DEBUG_IN;
        rand mci_reg__DEBUG_OUT DEBUG_OUT;
        rand mci_reg__FUSE_WR_DONE FUSE_WR_DONE;
        rand mci_reg__PROD_DEBUG_UNLOCK_PK_HASH_REG PROD_DEBUG_UNLOCK_PK_HASH_REG[8][12];
        rand mci_reg__STICKY_DATA_VAULT_CTRL STICKY_DATA_VAULT_CTRL[10];
        rand mci_reg__STICKY_DATA_VAULT_ENTRY STICKY_DATA_VAULT_ENTRY[10][12];
        rand mci_reg__DATA_VAULT_CTRL DATA_VAULT_CTRL[10];
        rand mci_reg__DATA_VAULT_ENTRY DATA_VAULT_ENTRY[10][12];
        rand mci_reg__STICKY_LOCKABLE_SCRATCH_REG_CTRL STICKY_LOCKABLE_SCRATCH_REG_CTRL[8];
        rand mci_reg__STICKY_LOCKABLE_SCRATCH_REG STICKY_LOCKABLE_SCRATCH_REG[8];
        rand mci_reg__LOCKABLE_SCRATCH_REG_CTRL LOCKABLE_SCRATCH_REG_CTRL[10];
        rand mci_reg__LOCKABLE_SCRATCH_REG LOCKABLE_SCRATCH_REG[10];
        rand mci_reg__NON_STICKY_GENERIC_SCRATCH_REG NON_STICKY_GENERIC_SCRATCH_REG[8];

        function new(string name = "mci_reg");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_LITTLE_ENDIAN);
            this.CAPABILITIES = new("CAPABILITIES");
            this.CAPABILITIES.configure(this);

            this.CAPABILITIES.build();
            this.default_map.add_reg(this.CAPABILITIES, 'h0);
            this.HW_REV_ID = new("HW_REV_ID");
            this.HW_REV_ID.configure(this);

            this.HW_REV_ID.build();
            this.default_map.add_reg(this.HW_REV_ID, 'h4);
            foreach(this.FW_REV_ID[i0]) begin
                this.FW_REV_ID[i0] = new($sformatf("FW_REV_ID[%0d]", i0));
                this.FW_REV_ID[i0].configure(this);
                
                this.FW_REV_ID[i0].build();
                this.default_map.add_reg(this.FW_REV_ID[i0], 'h8 + i0*'h4);
            end
            this.HW_CONFIG = new("HW_CONFIG");
            this.HW_CONFIG.configure(this);

            this.HW_CONFIG.build();
            this.default_map.add_reg(this.HW_CONFIG, 'h10);
            this.BOOT_STATUS = new("BOOT_STATUS");
            this.BOOT_STATUS.configure(this);

            this.BOOT_STATUS.build();
            this.default_map.add_reg(this.BOOT_STATUS, 'h20);
            this.FLOW_STATUS = new("FLOW_STATUS");
            this.FLOW_STATUS.configure(this);

            this.FLOW_STATUS.build();
            this.default_map.add_reg(this.FLOW_STATUS, 'h24);
            this.RESET_REASON = new("RESET_REASON");
            this.RESET_REASON.configure(this);

            this.RESET_REASON.build();
            this.default_map.add_reg(this.RESET_REASON, 'h28);
            this.HW_ERROR_FATAL = new("HW_ERROR_FATAL");
            this.HW_ERROR_FATAL.configure(this);

            this.HW_ERROR_FATAL.build();
            this.default_map.add_reg(this.HW_ERROR_FATAL, 'h40);
            this.HW_ERROR_NON_FATAL = new("HW_ERROR_NON_FATAL");
            this.HW_ERROR_NON_FATAL.configure(this);

            this.HW_ERROR_NON_FATAL.build();
            this.default_map.add_reg(this.HW_ERROR_NON_FATAL, 'h44);
            this.FW_ERROR_FATAL = new("FW_ERROR_FATAL");
            this.FW_ERROR_FATAL.configure(this);

            this.FW_ERROR_FATAL.build();
            this.default_map.add_reg(this.FW_ERROR_FATAL, 'h48);
            this.FW_ERROR_NON_FATAL = new("FW_ERROR_NON_FATAL");
            this.FW_ERROR_NON_FATAL.configure(this);

            this.FW_ERROR_NON_FATAL.build();
            this.default_map.add_reg(this.FW_ERROR_NON_FATAL, 'h4c);
            this.HW_ERROR_ENC = new("HW_ERROR_ENC");
            this.HW_ERROR_ENC.configure(this);

            this.HW_ERROR_ENC.build();
            this.default_map.add_reg(this.HW_ERROR_ENC, 'h50);
            this.FW_ERROR_ENC = new("FW_ERROR_ENC");
            this.FW_ERROR_ENC.configure(this);

            this.FW_ERROR_ENC.build();
            this.default_map.add_reg(this.FW_ERROR_ENC, 'h54);
            foreach(this.FW_EXTENDED_ERROR_INFO[i0]) begin
                this.FW_EXTENDED_ERROR_INFO[i0] = new($sformatf("FW_EXTENDED_ERROR_INFO[%0d]", i0));
                this.FW_EXTENDED_ERROR_INFO[i0].configure(this);
                
                this.FW_EXTENDED_ERROR_INFO[i0].build();
                this.default_map.add_reg(this.FW_EXTENDED_ERROR_INFO[i0], 'h58 + i0*'h4);
            end
            this.WDT_TIMER1_EN = new("WDT_TIMER1_EN");
            this.WDT_TIMER1_EN.configure(this);

            this.WDT_TIMER1_EN.build();
            this.default_map.add_reg(this.WDT_TIMER1_EN, 'h80);
            this.WDT_TIMER1_CTRL = new("WDT_TIMER1_CTRL");
            this.WDT_TIMER1_CTRL.configure(this);

            this.WDT_TIMER1_CTRL.build();
            this.default_map.add_reg(this.WDT_TIMER1_CTRL, 'h84);
            foreach(this.WDT_TIMER1_TIMEOUT_PERIOD[i0]) begin
                this.WDT_TIMER1_TIMEOUT_PERIOD[i0] = new($sformatf("WDT_TIMER1_TIMEOUT_PERIOD[%0d]", i0));
                this.WDT_TIMER1_TIMEOUT_PERIOD[i0].configure(this);
                
                this.WDT_TIMER1_TIMEOUT_PERIOD[i0].build();
                this.default_map.add_reg(this.WDT_TIMER1_TIMEOUT_PERIOD[i0], 'h88 + i0*'h4);
            end
            this.WDT_TIMER2_EN = new("WDT_TIMER2_EN");
            this.WDT_TIMER2_EN.configure(this);

            this.WDT_TIMER2_EN.build();
            this.default_map.add_reg(this.WDT_TIMER2_EN, 'h90);
            this.WDT_TIMER2_CTRL = new("WDT_TIMER2_CTRL");
            this.WDT_TIMER2_CTRL.configure(this);

            this.WDT_TIMER2_CTRL.build();
            this.default_map.add_reg(this.WDT_TIMER2_CTRL, 'h94);
            foreach(this.WDT_TIMER2_TIMEOUT_PERIOD[i0]) begin
                this.WDT_TIMER2_TIMEOUT_PERIOD[i0] = new($sformatf("WDT_TIMER2_TIMEOUT_PERIOD[%0d]", i0));
                this.WDT_TIMER2_TIMEOUT_PERIOD[i0].configure(this);
                
                this.WDT_TIMER2_TIMEOUT_PERIOD[i0].build();
                this.default_map.add_reg(this.WDT_TIMER2_TIMEOUT_PERIOD[i0], 'h98 + i0*'h4);
            end
            this.WDT_STATUS = new("WDT_STATUS");
            this.WDT_STATUS.configure(this);

            this.WDT_STATUS.build();
            this.default_map.add_reg(this.WDT_STATUS, 'ha0);
            foreach(this.WDT_CFG[i0]) begin
                this.WDT_CFG[i0] = new($sformatf("WDT_CFG[%0d]", i0));
                this.WDT_CFG[i0].configure(this);
                
                this.WDT_CFG[i0].build();
                this.default_map.add_reg(this.WDT_CFG[i0], 'hb0 + i0*'h4);
            end
            this.MCU_TIMER_CONFIG = new("MCU_TIMER_CONFIG");
            this.MCU_TIMER_CONFIG.configure(this);

            this.MCU_TIMER_CONFIG.build();
            this.default_map.add_reg(this.MCU_TIMER_CONFIG, 'hc0);
            this.MCU_CLK_GATING_EN = new("MCU_CLK_GATING_EN");
            this.MCU_CLK_GATING_EN.configure(this);

            this.MCU_CLK_GATING_EN.build();
            this.default_map.add_reg(this.MCU_CLK_GATING_EN, 'hc4);
            this.MCU_RV_MTIME_L = new("MCU_RV_MTIME_L");
            this.MCU_RV_MTIME_L.configure(this);

            this.MCU_RV_MTIME_L.build();
            this.default_map.add_reg(this.MCU_RV_MTIME_L, 'hc8);
            this.MCU_RV_MTIME_H = new("MCU_RV_MTIME_H");
            this.MCU_RV_MTIME_H.configure(this);

            this.MCU_RV_MTIME_H.build();
            this.default_map.add_reg(this.MCU_RV_MTIME_H, 'hcc);
            this.MCU_RV_MTIMECMP_L = new("MCU_RV_MTIMECMP_L");
            this.MCU_RV_MTIMECMP_L.configure(this);

            this.MCU_RV_MTIMECMP_L.build();
            this.default_map.add_reg(this.MCU_RV_MTIMECMP_L, 'hd0);
            this.MCU_RV_MTIMECMP_H = new("MCU_RV_MTIMECMP_H");
            this.MCU_RV_MTIMECMP_H.configure(this);

            this.MCU_RV_MTIMECMP_H.build();
            this.default_map.add_reg(this.MCU_RV_MTIMECMP_H, 'hd4);
            this.RESET_REQUEST = new("RESET_REQUEST");
            this.RESET_REQUEST.configure(this);

            this.RESET_REQUEST.build();
            this.default_map.add_reg(this.RESET_REQUEST, 'h100);
            this.RESET_ACK = new("RESET_ACK");
            this.RESET_ACK.configure(this);

            this.RESET_ACK.build();
            this.default_map.add_reg(this.RESET_ACK, 'h104);
            this.CALIPTRA_BOOT_GO = new("CALIPTRA_BOOT_GO");
            this.CALIPTRA_BOOT_GO.configure(this);

            this.CALIPTRA_BOOT_GO.build();
            this.default_map.add_reg(this.CALIPTRA_BOOT_GO, 'h108);
            this.CALIPTRA_AXI_ID = new("CALIPTRA_AXI_ID");
            this.CALIPTRA_AXI_ID.configure(this);

            this.CALIPTRA_AXI_ID.build();
            this.default_map.add_reg(this.CALIPTRA_AXI_ID, 'h10c);
            this.FW_SRAM_EXEC_REGION_SIZE = new("FW_SRAM_EXEC_REGION_SIZE");
            this.FW_SRAM_EXEC_REGION_SIZE.configure(this);

            this.FW_SRAM_EXEC_REGION_SIZE.build();
            this.default_map.add_reg(this.FW_SRAM_EXEC_REGION_SIZE, 'h110);
            this.RUNTIME_LOCK = new("RUNTIME_LOCK");
            this.RUNTIME_LOCK.configure(this);

            this.RUNTIME_LOCK.build();
            this.default_map.add_reg(this.RUNTIME_LOCK, 'h114);
            foreach(this.MBOX0_VALID_AXI_ID[i0]) begin
                this.MBOX0_VALID_AXI_ID[i0] = new($sformatf("MBOX0_VALID_AXI_ID[%0d]", i0));
                this.MBOX0_VALID_AXI_ID[i0].configure(this);
                
                this.MBOX0_VALID_AXI_ID[i0].build();
                this.default_map.add_reg(this.MBOX0_VALID_AXI_ID[i0], 'h180 + i0*'h4);
            end
            foreach(this.MBOX0_VALID_AXI_ID_LOCK[i0]) begin
                this.MBOX0_VALID_AXI_ID_LOCK[i0] = new($sformatf("MBOX0_VALID_AXI_ID_LOCK[%0d]", i0));
                this.MBOX0_VALID_AXI_ID_LOCK[i0].configure(this);
                
                this.MBOX0_VALID_AXI_ID_LOCK[i0].build();
                this.default_map.add_reg(this.MBOX0_VALID_AXI_ID_LOCK[i0], 'h1a0 + i0*'h4);
            end
            foreach(this.MBOX1_VALID_AXI_ID[i0]) begin
                this.MBOX1_VALID_AXI_ID[i0] = new($sformatf("MBOX1_VALID_AXI_ID[%0d]", i0));
                this.MBOX1_VALID_AXI_ID[i0].configure(this);
                
                this.MBOX1_VALID_AXI_ID[i0].build();
                this.default_map.add_reg(this.MBOX1_VALID_AXI_ID[i0], 'h1c0 + i0*'h4);
            end
            foreach(this.MBOX1_VALID_AXI_ID_LOCK[i0]) begin
                this.MBOX1_VALID_AXI_ID_LOCK[i0] = new($sformatf("MBOX1_VALID_AXI_ID_LOCK[%0d]", i0));
                this.MBOX1_VALID_AXI_ID_LOCK[i0].configure(this);
                
                this.MBOX1_VALID_AXI_ID_LOCK[i0].build();
                this.default_map.add_reg(this.MBOX1_VALID_AXI_ID_LOCK[i0], 'h1e0 + i0*'h4);
            end
            foreach(this.GENERIC_INPUT_WIRES[i0]) begin
                this.GENERIC_INPUT_WIRES[i0] = new($sformatf("GENERIC_INPUT_WIRES[%0d]", i0));
                this.GENERIC_INPUT_WIRES[i0].configure(this);
                
                this.GENERIC_INPUT_WIRES[i0].build();
                this.default_map.add_reg(this.GENERIC_INPUT_WIRES[i0], 'h400 + i0*'h4);
            end
            foreach(this.GENERIC_OUTPUT_WIRES[i0]) begin
                this.GENERIC_OUTPUT_WIRES[i0] = new($sformatf("GENERIC_OUTPUT_WIRES[%0d]", i0));
                this.GENERIC_OUTPUT_WIRES[i0].configure(this);
                
                this.GENERIC_OUTPUT_WIRES[i0].build();
                this.default_map.add_reg(this.GENERIC_OUTPUT_WIRES[i0], 'h408 + i0*'h4);
            end
            this.DEBUG_IN = new("DEBUG_IN");
            this.DEBUG_IN.configure(this);

            this.DEBUG_IN.build();
            this.default_map.add_reg(this.DEBUG_IN, 'h410);
            this.DEBUG_OUT = new("DEBUG_OUT");
            this.DEBUG_OUT.configure(this);

            this.DEBUG_OUT.build();
            this.default_map.add_reg(this.DEBUG_OUT, 'h414);
            this.FUSE_WR_DONE = new("FUSE_WR_DONE");
            this.FUSE_WR_DONE.configure(this);

            this.FUSE_WR_DONE.build();
            this.default_map.add_reg(this.FUSE_WR_DONE, 'h440);
            foreach(this.PROD_DEBUG_UNLOCK_PK_HASH_REG[i0, i1]) begin
                this.PROD_DEBUG_UNLOCK_PK_HASH_REG[i0][i1] = new($sformatf("PROD_DEBUG_UNLOCK_PK_HASH_REG[%0d][%0d]", i0, i1));
                this.PROD_DEBUG_UNLOCK_PK_HASH_REG[i0][i1].configure(this);
                
                this.PROD_DEBUG_UNLOCK_PK_HASH_REG[i0][i1].build();
                this.default_map.add_reg(this.PROD_DEBUG_UNLOCK_PK_HASH_REG[i0][i1], 'h480 + i0*'h30 + i1*'h4);
            end
            foreach(this.STICKY_DATA_VAULT_CTRL[i0]) begin
                this.STICKY_DATA_VAULT_CTRL[i0] = new($sformatf("STICKY_DATA_VAULT_CTRL[%0d]", i0));
                this.STICKY_DATA_VAULT_CTRL[i0].configure(this);
                
                this.STICKY_DATA_VAULT_CTRL[i0].build();
                this.default_map.add_reg(this.STICKY_DATA_VAULT_CTRL[i0], 'h800 + i0*'h4);
            end
            foreach(this.STICKY_DATA_VAULT_ENTRY[i0, i1]) begin
                this.STICKY_DATA_VAULT_ENTRY[i0][i1] = new($sformatf("STICKY_DATA_VAULT_ENTRY[%0d][%0d]", i0, i1));
                this.STICKY_DATA_VAULT_ENTRY[i0][i1].configure(this);
                
                this.STICKY_DATA_VAULT_ENTRY[i0][i1].build();
                this.default_map.add_reg(this.STICKY_DATA_VAULT_ENTRY[i0][i1], 'h828 + i0*'h30 + i1*'h4);
            end
            foreach(this.DATA_VAULT_CTRL[i0]) begin
                this.DATA_VAULT_CTRL[i0] = new($sformatf("DATA_VAULT_CTRL[%0d]", i0));
                this.DATA_VAULT_CTRL[i0].configure(this);
                
                this.DATA_VAULT_CTRL[i0].build();
                this.default_map.add_reg(this.DATA_VAULT_CTRL[i0], 'ha08 + i0*'h4);
            end
            foreach(this.DATA_VAULT_ENTRY[i0, i1]) begin
                this.DATA_VAULT_ENTRY[i0][i1] = new($sformatf("DATA_VAULT_ENTRY[%0d][%0d]", i0, i1));
                this.DATA_VAULT_ENTRY[i0][i1].configure(this);
                
                this.DATA_VAULT_ENTRY[i0][i1].build();
                this.default_map.add_reg(this.DATA_VAULT_ENTRY[i0][i1], 'ha30 + i0*'h30 + i1*'h4);
            end
            foreach(this.STICKY_LOCKABLE_SCRATCH_REG_CTRL[i0]) begin
                this.STICKY_LOCKABLE_SCRATCH_REG_CTRL[i0] = new($sformatf("STICKY_LOCKABLE_SCRATCH_REG_CTRL[%0d]", i0));
                this.STICKY_LOCKABLE_SCRATCH_REG_CTRL[i0].configure(this);
                
                this.STICKY_LOCKABLE_SCRATCH_REG_CTRL[i0].build();
                this.default_map.add_reg(this.STICKY_LOCKABLE_SCRATCH_REG_CTRL[i0], 'hc10 + i0*'h4);
            end
            foreach(this.STICKY_LOCKABLE_SCRATCH_REG[i0]) begin
                this.STICKY_LOCKABLE_SCRATCH_REG[i0] = new($sformatf("STICKY_LOCKABLE_SCRATCH_REG[%0d]", i0));
                this.STICKY_LOCKABLE_SCRATCH_REG[i0].configure(this);
                
                this.STICKY_LOCKABLE_SCRATCH_REG[i0].build();
                this.default_map.add_reg(this.STICKY_LOCKABLE_SCRATCH_REG[i0], 'hc30 + i0*'h4);
            end
            foreach(this.LOCKABLE_SCRATCH_REG_CTRL[i0]) begin
                this.LOCKABLE_SCRATCH_REG_CTRL[i0] = new($sformatf("LOCKABLE_SCRATCH_REG_CTRL[%0d]", i0));
                this.LOCKABLE_SCRATCH_REG_CTRL[i0].configure(this);
                
                this.LOCKABLE_SCRATCH_REG_CTRL[i0].build();
                this.default_map.add_reg(this.LOCKABLE_SCRATCH_REG_CTRL[i0], 'hc50 + i0*'h4);
            end
            foreach(this.LOCKABLE_SCRATCH_REG[i0]) begin
                this.LOCKABLE_SCRATCH_REG[i0] = new($sformatf("LOCKABLE_SCRATCH_REG[%0d]", i0));
                this.LOCKABLE_SCRATCH_REG[i0].configure(this);
                
                this.LOCKABLE_SCRATCH_REG[i0].build();
                this.default_map.add_reg(this.LOCKABLE_SCRATCH_REG[i0], 'hc78 + i0*'h4);
            end
            foreach(this.NON_STICKY_GENERIC_SCRATCH_REG[i0]) begin
                this.NON_STICKY_GENERIC_SCRATCH_REG[i0] = new($sformatf("NON_STICKY_GENERIC_SCRATCH_REG[%0d]", i0));
                this.NON_STICKY_GENERIC_SCRATCH_REG[i0].configure(this);
                
                this.NON_STICKY_GENERIC_SCRATCH_REG[i0].build();
                this.default_map.add_reg(this.NON_STICKY_GENERIC_SCRATCH_REG[i0], 'hca0 + i0*'h4);
            end
        endfunction : build
    endclass : mci_reg

    `include "mci_reg_sample.svh"
endpackage: mci_reg_uvm
