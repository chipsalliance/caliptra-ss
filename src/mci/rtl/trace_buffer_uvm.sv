
// This file was autogenerated by PeakRDL-uvm
package trace_buffer_uvm;
    `include "uvm_macros.svh"
    import uvm_pkg::*;
    `include "trace_buffer_csr_covergroups.svh"
    // Reg - trace_buffer_csr::STATUS
    class trace_buffer_csr__STATUS extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        trace_buffer_csr__STATUS_bit_cg wrapped_bit_cg[1];
        trace_buffer_csr__STATUS_bit_cg valid_data_bit_cg[1];
        trace_buffer_csr__STATUS_fld_cg fld_cg;
        rand uvm_reg_field wrapped;
        rand uvm_reg_field valid_data;

        function new(string name = "trace_buffer_csr__STATUS");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.wrapped = new("wrapped");
            this.wrapped.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            this.valid_data = new("valid_data");
            this.valid_data.configure(this, 1, 1, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(wrapped_bit_cg[bt]) wrapped_bit_cg[bt] = new();
                foreach(valid_data_bit_cg[bt]) valid_data_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : trace_buffer_csr__STATUS

    // Reg - trace_buffer_csr::CONFIG
    class trace_buffer_csr__CONFIG extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        trace_buffer_csr__CONFIG_bit_cg trace_buffer_depth_bit_cg[1];
        trace_buffer_csr__CONFIG_fld_cg fld_cg;
        rand uvm_reg_field trace_buffer_depth;

        function new(string name = "trace_buffer_csr__CONFIG");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.trace_buffer_depth = new("trace_buffer_depth");
            this.trace_buffer_depth.configure(this, 1, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(trace_buffer_depth_bit_cg[bt]) trace_buffer_depth_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : trace_buffer_csr__CONFIG

    // Reg - trace_buffer_csr::DATA
    class trace_buffer_csr__DATA extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        trace_buffer_csr__DATA_bit_cg data_bit_cg[32];
        trace_buffer_csr__DATA_fld_cg fld_cg;
        rand uvm_reg_field data;

        function new(string name = "trace_buffer_csr__DATA");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.data = new("data");
            this.data.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(data_bit_cg[bt]) data_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : trace_buffer_csr__DATA

    // Reg - trace_buffer_csr::WRITE_PTR
    class trace_buffer_csr__WRITE_PTR extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        trace_buffer_csr__WRITE_PTR_bit_cg ptr_bit_cg[32];
        trace_buffer_csr__WRITE_PTR_fld_cg fld_cg;
        rand uvm_reg_field ptr;

        function new(string name = "trace_buffer_csr__WRITE_PTR");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ptr = new("ptr");
            this.ptr.configure(this, 32, 0, "RO", 1, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ptr_bit_cg[bt]) ptr_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : trace_buffer_csr__WRITE_PTR

    // Reg - trace_buffer_csr::READ_PTR
    class trace_buffer_csr__READ_PTR extends uvm_reg;
        protected uvm_reg_data_t m_current;
        protected uvm_reg_data_t m_data;
        protected bit            m_is_read;

        trace_buffer_csr__READ_PTR_bit_cg ptr_bit_cg[32];
        trace_buffer_csr__READ_PTR_fld_cg fld_cg;
        rand uvm_reg_field ptr;

        function new(string name = "trace_buffer_csr__READ_PTR");
            super.new(name, 32, build_coverage(UVM_CVR_ALL));
        endfunction : new
        extern virtual function void sample_values();
        extern protected virtual function void sample(uvm_reg_data_t  data,
                                                      uvm_reg_data_t  byte_en,
                                                      bit             is_read,
                                                      uvm_reg_map     map);

        virtual function void build();
            this.ptr = new("ptr");
            this.ptr.configure(this, 32, 0, "RW", 0, 'h0, 1, 1, 0);
            if (has_coverage(UVM_CVR_REG_BITS)) begin
                foreach(ptr_bit_cg[bt]) ptr_bit_cg[bt] = new();
            end
            if (has_coverage(UVM_CVR_FIELD_VALS))
                fld_cg = new();
        endfunction : build
    endclass : trace_buffer_csr__READ_PTR

    // Addrmap - trace_buffer_csr
    class trace_buffer_csr extends uvm_reg_block;
        rand trace_buffer_csr__STATUS STATUS;
        rand trace_buffer_csr__CONFIG CONFIG;
        rand trace_buffer_csr__DATA DATA;
        rand trace_buffer_csr__WRITE_PTR WRITE_PTR;
        rand trace_buffer_csr__READ_PTR READ_PTR;

        function new(string name = "trace_buffer_csr");
            super.new(name);
        endfunction : new

        virtual function void build();
            this.default_map = create_map("reg_map", 0, 4, UVM_LITTLE_ENDIAN);
            this.STATUS = new("STATUS");
            this.STATUS.configure(this);

            this.STATUS.build();
            this.default_map.add_reg(this.STATUS, 'h0);
            this.CONFIG = new("CONFIG");
            this.CONFIG.configure(this);

            this.CONFIG.build();
            this.default_map.add_reg(this.CONFIG, 'h4);
            this.DATA = new("DATA");
            this.DATA.configure(this);

            this.DATA.build();
            this.default_map.add_reg(this.DATA, 'h8);
            this.WRITE_PTR = new("WRITE_PTR");
            this.WRITE_PTR.configure(this);

            this.WRITE_PTR.build();
            this.default_map.add_reg(this.WRITE_PTR, 'hc);
            this.READ_PTR = new("READ_PTR");
            this.READ_PTR.configure(this);

            this.READ_PTR.build();
            this.default_map.add_reg(this.READ_PTR, 'h10);
        endfunction : build
    endclass : trace_buffer_csr

    `include "trace_buffer_csr_sample.svh"
endpackage: trace_buffer_uvm
