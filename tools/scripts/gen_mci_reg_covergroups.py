#!/usr/bin/env python3
# SPDX-License-Identifier: Apache-2.0
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

import re

"""Purpose: Generates a set of covergroups and related signal insantiations for MCI registers""" 

mci_regs_txt = """
HW_CAPABILITIES
FW_CAPABILITIES
CAP_LOCK
HW_REV_ID
FW_REV_ID 2
HW_CONFIG0
HW_CONFIG1
FW_FLOW_STATUS
HW_FLOW_STATUS
RESET_REASON
RESET_STATUS
SECURITY_STATE
HW_ERROR_FATAL
AGG_ERROR_FATAL
HW_ERROR_NON_FATAL
AGG_ERROR_NON_FATAL
FW_ERROR_FATAL
FW_ERROR_NON_FATAL
HW_ERROR_ENC
FW_ERROR_ENC
FW_EXTENDED_ERROR_INFO 8
WDT_TIMER1_EN
WDT_TIMER1_CTRL
WDT_TIMER1_TIMEOUT_PERIOD 2
WDT_TIMER2_EN
WDT_TIMER2_CTRL
WDT_TIMER2_TIMEOUT_PERIOD 2
WDT_STATUS
WDT_CFG 2
MCU_TIMER_CONFIG
MCU_RV_MTIME_L
MCU_RV_MTIME_H
MCU_RV_MTIMECMP_L
MCU_RV_MTIMECMP_H
RESET_REQUEST
MCI_BOOTFSM_GO
CPTRA_BOOT_GO
FW_SRAM_EXEC_REGION_SIZE
MCU_NMI_VECTOR
MCU_RESET_VECTOR
MBOX0_VALID_AXI_USER 5
MBOX0_AXI_USER_LOCK 5
MBOX1_VALID_AXI_USER 5
SOC_DFT_EN 2
SOC_HW_DEBUG_EN 2
SOC_PROD_DEBUG_STATE 2
FC_FIPS_ZEROZATION
GENERIC_INPUT_WIRES 2
GENERIC_OUTPUT_WIRES 2
DEBUG_IN
DEBUG_OUT
SS_DEBUG_INTENT
SS_CONFIG_DONE_STICKY
SS_CONFIG_DONE
PROD_DEBUG_UNLOCK_PK_HASH_REG_0 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_1 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_2 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_3 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_4 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_5 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_6 12
PROD_DEBUG_UNLOCK_PK_HASH_REG_7 12
INTR_BLOCK_RF_GLOBAL_INTR_EN_R
INTR_BLOCK_RF_ERROR0_INTR_EN_R
INTR_BLOCK_RF_ERROR1_INTR_EN_R
INTR_BLOCK_RF_NOTIF0_INTR_EN_R
INTR_BLOCK_RF_NOTIF1_INTR_EN_R
INTR_BLOCK_RF_ERROR_GLOBAL_INTR_R
INTR_BLOCK_RF_NOTIF_GLOBAL_INTR_R
INTR_BLOCK_RF_ERROR0_INTERNAL_INTR_R
INTR_BLOCK_RF_ERROR1_INTERNAL_INTR_R
INTR_BLOCK_RF_NOTIF0_INTERNAL_INTR_R
INTR_BLOCK_RF_NOTIF1_INTERNAL_INTR_R
INTR_BLOCK_RF_ERROR0_INTR_TRIG_R
INTR_BLOCK_RF_ERROR1_INTR_TRIG_R
INTR_BLOCK_RF_NOTIF0_INTR_TRIG_R
INTR_BLOCK_RF_NOTIF1_INTR_TRIG_R
INTR_BLOCK_RF_ERROR_INTERNAL_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_MBOX0_ECC_UNC_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_MBOX1_ECC_UNC_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_MCU_SRAM_DMI_AXI_COLLISION_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_WDT_TIMER1_TIMEOUT_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_WDT_TIMER2_TIMEOUT_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL0_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL1_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL2_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL3_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL4_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL5_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL6_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL7_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL8_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL9_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL10_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL11_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL12_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL13_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL14_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL15_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL16_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL17_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL18_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL19_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL20_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL21_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL22_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL23_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL24_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL25_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL26_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL27_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL28_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL29_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL30_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL31_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MCU_SRAM_ECC_COR_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_CPTRA_MCU_RESET_REQ_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_GEN_IN_TOGGLE_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL0_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL1_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL2_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL3_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL4_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL5_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL6_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL7_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL8_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL9_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL10_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL11_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL12_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL13_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL14_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL15_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL16_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL17_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL18_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL19_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL20_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL21_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL22_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL23_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL24_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL25_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL26_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL27_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL28_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL29_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL30_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL31_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX0_TARGET_DONE_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX1_TARGET_DONE_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX0_CMD_AVAIL_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX1_CMD_AVAIL_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_CPTRA_MBOX_CMD_AVAIL_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX0_ECC_COR_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX1_ECC_COR_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_DEBUG_LOCKED_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_SCAN_MODE_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX0_SOC_REQ_LOCK_INTR_COUNT_R
INTR_BLOCK_RF_NOTIF_MBOX1_SOC_REQ_LOCK_INTR_COUNT_R
INTR_BLOCK_RF_ERROR_INTERNAL_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_MBOX0_ECC_UNC_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_MBOX1_ECC_UNC_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_WDT_TIMER1_TIMEOUT_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_WDT_TIMER2_TIMEOUT_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_MCU_SRAM_DMI_AXI_COLLISION_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL0_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL1_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL2_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL3_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL4_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL5_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL6_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL7_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL8_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL9_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL10_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL11_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL12_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL13_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL14_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL15_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL16_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL17_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL18_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL19_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL20_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL21_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL22_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL23_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL24_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL25_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL26_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL27_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL28_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL29_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL30_INTR_COUNT_INCR_R
INTR_BLOCK_RF_ERROR_AGG_ERROR_FATAL31_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MCU_SRAM_ECC_COR_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_CPTRA_MCU_RESET_REQ_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_GEN_IN_TOGGLE_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL0_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL1_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL2_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL3_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL4_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL5_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL6_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL7_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL8_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL9_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL10_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL11_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL12_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL13_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL14_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL15_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL16_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL17_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL18_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL19_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL20_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL21_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL22_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL23_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL24_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL25_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL26_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL27_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL28_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL29_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL30_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_AGG_ERROR_NON_FATAL31_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX0_TARGET_DONE_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX1_TARGET_DONE_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX0_CMD_AVAIL_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX1_CMD_AVAIL_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_CPTRA_MBOX_CMD_AVAIL_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX0_ECC_COR_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX1_ECC_COR_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_DEBUG_LOCKED_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_SCAN_MODE_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX0_SOC_REQ_LOCK_INTR_COUNT_INCR_R
INTR_BLOCK_RF_NOTIF_MBOX1_SOC_REQ_LOCK_INTR_COUNT_INCR_R
"""
#MCU_TRACE_BUFFER_CSR_STATUS
#MCU_TRACE_BUFFER_CSR_DATA
#MCU_TRACE_BUFFER_CSR_WRITE_PTR
#MCU_TRACE_BUFFER_CSR_READ_PTR
#MCU_MBOX0_CSR_MBOX_LOCK
#MCU_MBOX0_CSR_MBOX_USER
#MCU_MBOX0_CSR_MBOX_TARGET_USER
#MCU_MBOX0_CSR_MBOX_TARGET_USER_VALID
#MCU_MBOX0_CSR_MBOX_CMD
#MCU_MBOX0_CSR_MBOX_DLEN
#MCU_MBOX0_CSR_MBOX_EXECUTE
#MCU_MBOX0_CSR_MBOX_TARGET_STATUS
#MCU_MBOX0_CSR_MBOX_CMD_STATUS
#MCU_MBOX0_CSR_MBOX_HW_STATUS
#MCU_MBOX1_CSR_MBOX_LOCK
#MCU_MBOX1_CSR_MBOX_USER
#MCU_MBOX1_CSR_MBOX_TARGET_USER
#MCU_MBOX1_CSR_MBOX_TARGET_USER_VALID
#MCU_MBOX1_CSR_MBOX_CMD
#MCU_MBOX1_CSR_MBOX_DLEN
#MCU_MBOX1_CSR_MBOX_EXECUTE
#MCU_MBOX1_CSR_MBOX_TARGET_STATUS
#MCU_MBOX1_CSR_MBOX_CMD_STATUS
#MCU_MBOX1_CSR_MBOX_HW_STATUS
#"""

# Registers to be excluded from coverage
commented_regs = set("HW_REV_ID HW_CONFIG0 HW_CONFIG1 SECURITY_STATE".split())

def main():
    rd_bins_txt = "bins rd = {AXI_RD};"
    wr_bins_txt = "bins wr = {AXI_WR};"
    ignore_bins_txt = "ignore_bins dont_care = {IDLE, 2'h3};"

    mci_regs = (reg.strip().split() for reg in mci_regs_txt.strip().splitlines())
    mci_regs = [(r[0], int(r[1])) if len(r) == 2 else (r[0], 1) for r in mci_regs] 

    print()
    print ("  // ------------------------------------------------------------------- ")
    print ("  // begin SCRIPT_OUTPUT") 
    print ("  // ------------------------------------------------------------------- \n")

    print (f"\n  // ------------------- COVERGROUP related signals & assigns -------------------\n")

    for rname, width in mci_regs:
        cb = "  // " if rname in commented_regs else "  "
    
        if rname.startswith("MCU_MBOX") or rname.startswith("MCU_TRACE"):    
            tickdef_prefix = f"`SOC_MCI_TOP_{rname}"
        else:
            tickdef_prefix = f"`SOC_MCI_TOP_MCI_REG_{rname}" 

        if width == 1:
            print (f"{cb}logic          hit_{rname};") 
            print (f"{cb}logic [1:0]    bus_{rname};")  # Changed from [3:0] to [1:0]
            print (f"{cb}logic [31:0]   full_addr_{rname} = {tickdef_prefix};\n") 
        else: 
            print (f"{cb}logic          hit_{rname}[0:{width-1}];") 
            print (f"{cb}logic [1:0]    bus_{rname}[0:{width-1}];")  # Changed from [3:0] to [1:0]
            print (f"{cb}logic [31:0]   full_addr_{rname}[0:{width-1}];")
            for i in range(width): 
                print (f"{cb}assign         full_addr_{rname}[{i}] = {tickdef_prefix}_{i};") 
            print()
    print()

    for rname, width in mci_regs:
        cb = "  // " if rname in commented_regs else "  "

        if width == 1:
            print (f"{cb}" + "assign hit_%s = (axi_addr == full_addr_%s[$bits(s_axi_r_if.araddr)-1:0]);" % (rname, rname))
            print (f"{cb}" + "assign bus_%s = {axi_rd, axi_wr} & {2{hit_%s}};\n" % (rname, rname))
        else: 
            for i in range(width): 
                print (f"{cb}" + "assign hit_%s[%d] = (axi_addr == full_addr_%s[%d][$bits(s_axi_r_if.araddr)-1:0]);" % (rname, i, rname, i))
                print (f"{cb}" + "assign bus_%s[%d] = {axi_rd, axi_wr} & {2{hit_%s[%d]}};\n" % (rname, i, rname, i))

    for rname, width in mci_regs:
        cb = "  // " if rname in commented_regs else "  "

        # Handle different field storage paths based on register type
        if rname.startswith("INTR_BLOCK_RF_"):
            # For interrupt block registers, we need special handling
            # First replace the prefix
            rname_mod = rname.replace("INTR_BLOCK_RF_", "intr_block_rf.")
            # Then convert the rest to lowercase
            rname_mod = "intr_block_rf." + rname.replace("INTR_BLOCK_RF_", "").lower()
        elif rname.startswith("PROD_DEBUG_UNLOCK_PK_HASH_REG_"):
            # Special handling for PROD_DEBUG_UNLOCK_PK_HASH_REG_X
            match = re.match(r'PROD_DEBUG_UNLOCK_PK_HASH_REG_(\d+)$', rname)
            if match:
                reg_idx = match.group(1)
                rname_mod = f"PROD_DEBUG_UNLOCK_PK_HASH_REG[{reg_idx}]"
            else:
                rname_mod = rname
        else:
            # For all other registers, maintain original case
            rname_mod = rname

        if width == 1:
            print (f"{cb}// ----------------------- COVERGROUP {rname} -----------------------")
            print (f"{cb}covergroup mci_{rname}_cg (ref logic [1:0] bus_event) @(posedge clk);")
            
            # All registers have a struct field as per requirement
            print (f"{cb}  {rname}_cp : coverpoint i_mci_reg_top.i_mci_reg.field_storage.{rname_mod};") 
            
            print (f"{cb}  bus_{rname}_cp : coverpoint bus_event", '{') 
            print (f"{cb}    {rd_bins_txt}") 
            print (f"{cb}    {wr_bins_txt}") 
            print (f"{cb}    {ignore_bins_txt}")
            print (f"{cb}  " + "}")
            
            print (f"{cb}endgroup\n")
        else:
            print (f"{cb}// ----------------------- COVERGROUP {rname} [0:{width-1}] -----------------------")
            print (f"{cb}covergroup mci_{rname}_cg (ref logic [1:0] bus_event[0:{width-1}]) @(posedge clk);")
            
            for i in range(width):
                # Handle array registers
                print (f"{cb}  {rname}_{i}_cp : coverpoint i_mci_reg_top.i_mci_reg.field_storage.{rname_mod}[{i}];")
                
                print (f"{cb}  bus_{rname}_{i}_cp : coverpoint bus_event[{i}]", '{') 
                print (f"{cb}    {rd_bins_txt}") 
                print (f"{cb}    {wr_bins_txt}")  
                print (f"{cb}    {ignore_bins_txt}")
                print (f"{cb}  " + "}")
            
            print (f"{cb}endgroup\n")

    print (f"\n  // ----------------------- COVERGROUP Instantiations -----------------------\n")

    for rname, width in mci_regs:
        cb = "  // " if rname in commented_regs else "  "
        print (f"{cb}mci_{rname}_cg {rname}_cg = new(bus_{rname});")

    print()
    print ("  // ------------------------------------------------------------------- ")
    print ("  // end SCRIPT_OUTPUT") 
    print ("  // ------------------------------------------------------------------- \n")

    print ("endinterface\n")
    print ()
    print ("`endif\n")

if __name__ == '__main__':
    main()