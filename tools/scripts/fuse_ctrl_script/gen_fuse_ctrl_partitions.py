#!/usr/bin/env python3
# Copyright lowRISC contributors (OpenTitan project).
# Licensed under the Apache License, Version 2.0, see LICENSE for details.
# SPDX-License-Identifier: Apache-2.0
r"""Generate RTL and documentation collateral from OTP memory
map definition file (hjson).
"""
import argparse
import logging as log
import sys
import yaml
from pathlib import Path
from typing import Dict

from mako import exceptions
from mako.template import Template

from lib.otp_mem_map import OtpMemMap
from lib.reggen.ip_block import IpBlock
from lib.reggen import gen_rtl
from lib.reggen import gen_dv
from lib.reggen import gen_md

HEADER_COMMENT = '''
DO NOT EDIT THIS FILE DIRECTLY.
It has been generated with ./tools/scripts/fuse_ctrl_script/gen_fuse_ctrl_partitions.py'''

HEADER_COMMENT_SV = HEADER_COMMENT.replace("\n", "\n// ")
HEADER_COMMENT_HJSON = HEADER_COMMENT_SV
HEADER_COMMENT_HTML = "<!--"+HEADER_COMMENT+"\n-->\n"

## Output paths
DATA_OUTPUT_PATH = Path("src") / "fuse_ctrl" / "data"
DOC_OUTPUT_PATH  = Path("src") / "fuse_ctrl" / "doc"
RTL_OUTPUT_PATH  = Path("src") / "fuse_ctrl" / "rtl"
DV_OUTPUT_PATH   = Path("src") / "fuse_ctrl" / "dv"
C_OUTPUT_PATH    = Path("src") / "integration" / "rtl"
RDL_OUTPUT_PATH  = Path("src") / "fuse_ctrl" / "rtl"

## Doc table files
PARTITIONS_TABLE_FILE = "otp_ctrl_partitions.md"
DIGESTS_TABLE_FILE    = "otp_ctrl_digests.md"
MMAP_TABLE_FILE       = "otp_ctrl_mmap.md"
DESC_TABLE_FILE       = "otp_ctrl_field_descriptions.md"
REGISTER_TABLE_FILE   = "otp_ctrl_registers.md"

## Templates
TEMPLATES_PATH    = Path("src") / "fuse_ctrl" / "templates"
DV_TEMPLATES_PATH = Path("src") / "fuse_ctrl" / "templates" / "dv"

# Config templates
MMAP_TEMPLATE  = "otp_ctrl_mmap.hjson.tpl"
HJSON_TEMPLATE = "otp_ctrl.hjson.tpl"
RDL_TEMPLATE   = "otp_ctrl.rdl.tpl"

# RTL templates
PART_PKG_TEMPLATE = "otp_ctrl_part_pkg.sv.tpl"
REG_PKG_TEMPLATE  = "reg_pkg.sv.tpl"
REG_TOP_TEMPLATE  = "reg_top.sv.tpl"

# DV templates
DV_README_TEMPLATE                = "README.md.tpl"
DV_BASE_VSEQ_TEMPLATE             = "otp_ctrl_base_vseq.sv.tpl"
DV_COMMON_VSEQ_TEMPLATE           = "otp_ctrl_common_vseq.sv.tpl"
DV_COV_TEMPLATE                   = "otp_ctrl_cov.core.tpl"
DV_COV_BIND_TEMPLATE              = "otp_ctrl_cov_bind.sv.tpl"
DV_COV_IF_TEMPLATE                = "otp_ctrl_cov_if.sv.tpl"
DV_DAI_LOCK_VSEQ_TEMPLATE         = "otp_ctrl_dai_lock_vseq.sv.tpl"
DV_ENV_TEMPLATE                   = "otp_ctrl_env.core.tpl"
DV_ENV_TEMPLATE                   = "otp_ctrl_env.sv.tpl"
DV_ENV_CFG_TEMPLATE               = "otp_ctrl_env_cfg.sv.tpl"
DV_ENV_COV_TEMPLATE               = "otp_ctrl_env_cov.sv.tpl"
DV_ENV_PKG_TEMPLATE               = "otp_ctrl_env_pkg.sv.tpl"
DV_IF_TEMPLATE                    = "otp_ctrl_if.sv.tpl"
DV_MEM_BKDR_UTIL_TEMPLATE         = "otp_ctrl_mem_bkdr_util.core.tpl"
DV_MEM_BKDR_UTIL_PKG_TEMPLATE     = "otp_ctrl_mem_bkdr_util_pkg.sv.tpl"
DV_PARALLEL_KEY_REQ_VSEQ_TEMPLATE = "otp_ctrl_parallel_key_req_vseq.sv.tpl"
DV_PARALLEL_LC_ESC_VSEQ_TEMPLATE  = "otp_ctrl_parallel_lc_esc_vseq.sv.tpl"
DV_SCOREBOARD_TEMPLATE            = "otp_ctrl_scoreboard.sv.tpl"
DV_SMOKE_VSEQ_TEMPLATE            = "otp_ctrl_smoke_vseq.sv.tpl"
DV_VIRTUAL_SEQUENCER_TEMPLATE     = "otp_ctrl_virtual_sequencer.sv.tpl"
DV_TB_TEMPLATE                    = "tb.sv.tpl"

# C templates
C_MMAP_TEMPLATE   = "fuse_ctrl_mmap.h.tpl"

def render_template(template: str, target_path: Path, params: Dict[str, object]):
    try:
        tpl = Template(filename=str(template))
    except OSError as e:
        log.error(f"Error creating template: {e}")
        exit(1)

    try:
        expansion = tpl.render(**params)
    except exceptions.MakoException:
        log.error(exceptions.text_error_template().render())
        exit(1)

    try:
        with target_path.open(mode='w', encoding='UTF-8') as outfile:
            outfile.write(expansion)
    except OSError as e:
        log.error(f"Error rendering template: {e}")
        exit(1)

def main():
    parser = argparse.ArgumentParser(prog="gen_fuse_ctrl_partitions")

    parser.add_argument('-f',
                        type=str,
                        default="./tools/scripts/fuse_ctrl_script/gen_fuse_ctrl_partitions.yml",
                        help='Vendor-specific fuses configuration file')
    args = parser.parse_args()

    with open(args.f) as f:
        try:
            vendor = yaml.safe_load(f)
        except yaml.YAMLERROR as err:
            log.error("failed to parse yaml file: %s" % err)
            exit(1)

    # Render mmap HJSON
    render_template(
        template=TEMPLATES_PATH / MMAP_TEMPLATE,
        target_path=DATA_OUTPUT_PATH / MMAP_TEMPLATE.replace(".tpl", ""),
        params={
            "num_vendor_pk_fuses": vendor["num_vendor_pk_fuses"],
            "num_vendor_secret_fuses": vendor["num_vendor_secret_fuses"],
            "num_vendor_non_secret_fuses": vendor["num_vendor_non_secret_fuses"],
            "num_ratchet_seed_partitions": vendor["num_ratchet_seed_partitions"]
        }
    )

    # Parse rendered mmap file
    otp_mmap = OtpMemMap.from_mmap_path(DATA_OUTPUT_PATH / MMAP_TEMPLATE.replace(".tpl", ""), None)

    # Render block HJSON
    render_template(
        template=TEMPLATES_PATH / HJSON_TEMPLATE,
        target_path=DATA_OUTPUT_PATH / HJSON_TEMPLATE.replace(".tpl", ""),
        params={"otp_mmap": otp_mmap, "gen_comment": HEADER_COMMENT_HJSON}
    )

    output_path = Path("src") / "fuse_ctrl" / "rtl"

    # Render partition package
    render_template(
        template=TEMPLATES_PATH / PART_PKG_TEMPLATE,
        target_path=RTL_OUTPUT_PATH / PART_PKG_TEMPLATE.replace(".tpl", ""),
        params={
            "otp_mmap": otp_mmap, "gen_comment": HEADER_COMMENT_SV,
            "num_vendor_pk_fuses": vendor["num_vendor_pk_fuses"],
            "num_vendor_secret_fuses": vendor["num_vendor_secret_fuses"],
            "num_vendor_non_secret_fuses": vendor["num_vendor_non_secret_fuses"],
            "num_ratchet_seed_partitions": vendor["num_ratchet_seed_partitions"]
        }
    )

    # Render register files
    ip_block = IpBlock.from_path(str(DATA_OUTPUT_PATH / HJSON_TEMPLATE.replace(".tpl", "")), [])
    gen_rtl.gen_rtl(ip_block, str(RTL_OUTPUT_PATH))

    # Render DV files
    ip_block = IpBlock.from_path(str(DATA_OUTPUT_PATH / HJSON_TEMPLATE.replace(".tpl", "")), [])
    gen_dv.gen_dv(ip_block, str(DV_OUTPUT_PATH))

    # Render RDL
    render_template(
        template=TEMPLATES_PATH / RDL_TEMPLATE,
        target_path=RDL_OUTPUT_PATH / RDL_TEMPLATE.replace(".tpl", ""),
        params={"partitions": otp_mmap.config["partitions"]}
    )

    # Render C header files
    render_template(
        template=TEMPLATES_PATH / C_MMAP_TEMPLATE,
        target_path=C_OUTPUT_PATH / C_MMAP_TEMPLATE.replace(".tpl", ""),
        params={"partitions": otp_mmap.config["partitions"]}
    )

    # Render doc tables
    with open(DOC_OUTPUT_PATH/ PARTITIONS_TABLE_FILE, 'wb', buffering=2097152) as outfile:
        outfile.write(HEADER_COMMENT_HTML.encode('utf-8'))
        outfile.write(otp_mmap.create_partitions_table().encode('utf-8'))
        outfile.write('\n'.encode('utf-8'))

    with open(DOC_OUTPUT_PATH / DIGESTS_TABLE_FILE, 'wb', buffering=2097152) as outfile:
        outfile.write(HEADER_COMMENT_HTML.encode('utf-8'))
        outfile.write(otp_mmap.create_digests_table().encode('utf-8'))
        outfile.write('\n'.encode('utf-8'))

    with open(DOC_OUTPUT_PATH / MMAP_TABLE_FILE, 'wb', buffering=2097152) as outfile:
        outfile.write(HEADER_COMMENT_HTML.encode('utf-8'))
        outfile.write(otp_mmap.create_mmap_table().encode('utf-8'))
        outfile.write('\n'.encode('utf-8'))

    with open(DOC_OUTPUT_PATH / DESC_TABLE_FILE, 'wb', buffering=2097152) as outfile:
        outfile.write(HEADER_COMMENT_HTML.encode('utf-8'))
        outfile.write(otp_mmap.create_description_table().encode('utf-8'))
        outfile.write('\n'.encode('utf-8'))
    with open(DOC_OUTPUT_PATH / REGISTER_TABLE_FILE, 'w', buffering=2097152) as outfile:
        gen_md.gen_md(ip_block, outfile)

if __name__ == "__main__":
    main()
